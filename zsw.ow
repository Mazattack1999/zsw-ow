settings
{
	main
	{
		Description: "Fight against an endless horde of zombies while completing various objectives.\r\n		Use power ups found in supply drops while you fight off the horde. 	\r\n		Get to the extraction point and watch the map get nuked.\r\n		Don't leave anyone behind!\r\n		\r\n		(Original Creator: Mazattack#1183) [Game Code: MEBGG] \r\n		Discord: https://discord.gg/3BhYtNfwMj		\r\nhttps://workshop.codes/MEBGG\r\n		Github: github.com/Mazattack1999/zsw-ow"
		Mode Name: "Zombie Survival Watch"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Map Rotation: After A Game
		Max Spectators: 7
		Max Team 2 Players: 6
		Max Team 1 Players: 0
		Return To Lobby: Never
		Swap Teams After Match: No
		Team Balancing: After A Game
	}

	modes
	{
		disabled Assault
		{
			Allow Hero Switching: On
			Capture Speed Modifier: 100%
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled
		}

		disabled Capture the Flag
		{
			Allow Hero Switching: On
			Damage Interrupts Flag Interaction: On
			Flag Carrier Abilities: All
			Flag Dropped Lock Time: 10.0
			Flag Pickup Time: 5.0
			Flag Return Time: 0.0
			Flag Score Respawn Time: 20.0
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled
		}

		disabled Control
		{
			Allow Hero Switching: On
			Capture Speed Modifier: 100%
			Game Mode Start: Manual
			Kill Cam: Off
			Scoring Speed Modifier: 100%
			Tank Role Passive Health Bonus: Always Enabled
		}

		Escort
		{
			Allow Hero Switching: On
			Game Mode Start: Manual
			Kill Cam: Off
			Payload Speed Modifier: 100%
			Tank Role Passive Health Bonus: Always Enabled
		}

		disabled Flashpoint
		{
			Capture Speed Modifier: 100%
			First Active Control Point: A
			Score To Win: 3
			Scoring Speed Modifier: 100%
			Tank Role Passive Health Bonus: Always Enabled
		}

		Hybrid
		{
			Allow Hero Switching: On
			Capture Speed Modifier: 100%
			Game Mode Start: Manual
			Kill Cam: Off
			Payload Speed Modifier: 100%
			Tank Role Passive Health Bonus: Always Enabled

			disabled maps
			{
				King's Row
			}
		}

		disabled Push
		{
			Allow Hero Switching: On
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled
			TS-1 Push Speed Modifier: 100%
			TS-1 Walk Speed Modifier: 100%
		}

		disabled Team Deathmatch
		{
			Allow Hero Switching: On
			Game Mode Start: Manual
			Kill Cam: Off
			Tank Role Passive Health Bonus: Always Enabled
		}
	}

	heroes
	{
		Team 1
		{
			Ability Cooldown Time: 0%
			No Ammunition Requirement: On

			D.Va
			{
				Spawn Without Mech: On
			}
		}
	}

	workshop
	{
		Boss Size: 2.500
		Chance to mutate percentage: 25.000
		Default Enhancement: [9]
		Heavy Knockback Reduction Scalar Scalar: 0.500
		Radioactivity Damage Scalar: 2.000
		Size Growth Scalar: 1.500
		Size Reduction Scalar: 0.600
		Speed Scalar: 1.500
		Zombie Size: 1.000
	}

	extensions
	{
		Spawn More Dummy Bots
	}
}

variables
{
	global:
		0: objectivePositions
		1: walkCenter
		2: objectiveCaptureValue
		3: startPos
		4: count1
		5: count2
		6: specialEffectsStrings
		7: playersOnObjective
		8: testPos
		9: testPos2
		10: objectiveTypes
		11: objectiveRad
		12: losList
		13: reviveRadius
		14: botHeros
		15: chase1
		18: gameStatus
		19: startTime
		20: mustReviveTime
		21: supplyDropLanding
		22: supplyDropPosition
		23: powerUpIDs
		24: powerUpPositions
		25: supplyDropStatus
		26: powerUpText
		27: powerUpEffect
		28: startCamPos
		29: botSpawnRates
		30: startMenuSpacingAngle
		31: startCamDistance
		32: overtime
		33: difficultyVotes
		34: botMaxTeleportRange
		35: difficultySetting
		36: biteDamages
		37: biteDurations
		38: damageDealt
		39: botHealthValues
		40: throttleSpeeds
		41: randVal
		42: specialEffectsTiming
		43: evacRate
		44: evacuatingSurvivorList
		45: evacDestination
		46: zombieSetting
		47: bosses
		48: zombieVotes
		49: globalPlayerStats
		50: objectiveTypeVotes
		51: objectiveTypeSetting
		52: eliminationsNeededPerObjective
		53: invisibilityHeros
		54: healthpackPositions
		55: wordsOfEncouragement
		56: mapGrid
		58: attackSpawnRooms
		59: activeAttackSpawnRoom
		60: closestPlayerToObjective
		61: botSpawnPoints
		62: objectiveValue
		63: objectiveEntities
		64: objectiveEntityCount
		65: voting
		66: votingEndTime
		67: objectiveResourcePositions
		68: amountPerResource
		69: extractionZoneRad
		70: specialGameModeSetup
		71: resourcePowerUpDropCount
		72: availablePowerups
		73: specialGameMode
		74: objectiveSpacing
		75: enhancementOptions
		76: playerTargetList
		77: losHeightCheck
		78: survivorToRescue
		79: nonBossZombies
		80: availableMutations
		81: numberOfPowerUpsPerSupplyDrop
		82: objectiveDescription
		83: mixedObjectivesPool
		84: uniqueSkinCap
		85: users
		86: objectiveComplete
		87: objectiveColor
		88: objectiveCount1
		89: objectiveChase1
		90: spawnRoomIndex
		91: averageVote
		92: matchEndTime
		93: waypoints
		94: availableBosses
		95: spawnTimes
		96: numberOfBots
		97: customTelePositions
		98: currentBotHeroList
		99: botCurrentSpawnRate
		100: botRespawnCount
		101: botSpawnPointTimers

	player:
		0: averagePlayersPos
		1: targeting
		4: teleporting
		5: pPowerUpCount_bTeleCount
		6: pForceFieldCount1
		7: pForceFieldCount2_bCount1
		9: botTarget
		10: botThrottleSpeed
		11: playerActiveStatus
		12: reviving
		13: reviveStartTime
		14: reviveTimer
		15: interactEntity
		16: infected
		17: biteDamage
		18: biteDuration
		19: randVal
		20: crowdControlled
		21: deathTimer
		22: infectionLvl
		23: currentPowerUp
		24: powerUpTradeValues
		25: powerUpEffects
		26: powerUpUsePositionsAndInfo
		27: pNoCooldownsCount_bCount2
		28: pAirStrikeCount
		30: chase1
		31: chase2
		32: botFollowTarget
		34: playerMenuStatus
		35: startPos
		36: successfullyTeleported
		39: evacPos
		40: canWallPhase
		41: pHealBeaconCount
		42: pSentryTurretCount
		43: initialMaxHealth
		44: botSpecialTarget
		45: attached
		46: telePos
		47: invisible
		48: pCloakingDeviceCount
		49: path
		50: potentialTargets
		51: pSuperNanoCount
		52: size
		53: bossHealth
		54: wallCollisionEnabled
		55: specialFacing
		56: specialThrottling
		57: filteredBotSpawnPointGrid
		58: botTempValue
		59: objectiveValue
		60: generalPlayerBotEntities
		61: entityCount
		62: botHero
		63: playerObjectiveResourceValue
		64: pBouncePadCount1
		66: enhancementValues
		67: botSpecialPotentialTargets
		68: movementSpeed
		69: mutationValue
		70: health
		71: damageOverTimeDuration
		72: pUltimateChargerCount
		73: enhancementChase1
		74: playerCollisionEnabled
		75: pStunCount
		76: enhancementChase2
		77: initializing
		78: userIndex
		79: knockbackRecieved
		80: detectionRadius1
		81: pBouncePadCount2
		82: bouncePadBouncer
		83: pStunChase1
		84: enhancementCount1
		85: customTelePos
		86: damageDealt
		87: lastTarget
		88: abilityArray1
		89: abilityArray2
		90: waypoint
		91: testTarget
		92: canTeleport
		93: defaultOutlineColor
		94: outlineCount
		95: blinded
		96: updateOutlines
		97: afk
}

subroutines
{
	0: enterExitTeleport
	1: teleportBots
	2: nukeMap
	3: powerUpAssignment
	4: powerUpUsage
	5: playerForceField
	6: noCooldowns
	7: airStrike
	8: instantRevive
	9: randomActions
	10: enableDisableAbilities
	11: determineDifficulty
	12: setDifficulty
	13: botRespawnInitialization
	14: determineZombieMode
	15: setZombieMode
	16: healBeacon
	17: sentryTurret
	18: needReviveTextLines
	19: cloakingDevice
	20: determineObjectiveType
	21: setObjectiveType
	22: objectivesManagement
	23: superNano
	24: generateMapGrid
	25: successfulTeleportStatus
	26: updateBotSpawnPoints
	27: globalObjectiveEntityManagement
	28: playerObjectiveEntityManagement
	29: botEntityManagement
	30: bouncePad
	31: botTeleportCenter
	32: locateAveragePlayerLocation
	33: enablePowerups
	34: mutations
	35: enableMutations
	36: ultimateCharger
	37: botHeroRandomization
	38: enableEnhancements
	39: scavengerManagement
	40: setAvailableObjectives
	41: stun
	42: updateUsers
	43: botStatManagement
	44: fireSatellite
	45: selectTarget
	46: restoreDefaultFacingMovement
	47: setPrematchTimer
}

rule("Fix bot health")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.initializing != True;
		Event Player.teleporting != True;
		Health(Event Player) > Event Player.health + 5;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Set Player Health(Event Player, Event Player.health);
		Loop If Condition Is True;
	}
}

disabled rule("interact test")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Button Held(Host Player, Button(Interact)) == True;
	}

	actions
	{
		Heal(Host Player, Null, 100000);
		Set Damage Dealt(Host Player, 1000);
		disabled Set Ultimate Charge(Host Player, 100);
		Set Status(All Players(Team 2), Null, Unkillable, 9999);
		If(Is Button Held(Host Player, Button(Primary Fire)));
			All Players(Team 2).currentPowerUp = 12;
		End;
	}
}

disabled rule("============================================== GLOBAL STARTUP ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PREGAME QUICK TIPS FOR PLAYERS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
	}

	actions
	{
		Wait(10, Abort When False);
		Small Message(All Players(All Teams), Custom String("Quick Tip: {0}", Random Value In Array(Array(Custom String(
			"Hold [{0}] while voting to cycle backwards.", Input Binding String(Button(Secondary Fire))), Custom String(
			"Zombies infect {0} players by hitting them.", Icon String(Poison)), Custom String(
			"Zombies with different colored outlines have mutations that grant them special buffs."), Custom String(
			"Hacked {0} zombies cannot infect players.", Ability Icon String(Hero(Sombra), Button(Secondary Fire))), Custom String(
			"Shields {0} block most zombie attacks including roadhog gas attacks. ", Ability Icon String(Hero(Reinhardt), Button(
			Secondary Fire))), Custom String("Zombies cannot spawn close to players or within their field of view. "), Custom String(
			"Overheal abilities such as rally {0} protect players from infection.", Ability Icon String(Hero(Brigitte), Button(Ultimate))),
			Custom String("Healthpacks {0} only cure infection {1} before overtime.", Icon String(Plus), Icon String(Poison))))));
		Loop;
	}
}

rule("SPAWN BOTS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Server Load Average <= Workshop Setting Integer(Custom String("General"), Custom String(
			"Spawn Zombies When Server Load Average is Less Than"), 180, 100, 255, 2);
		Number Of Players(All Teams) < 24;
		((Count Of(Global.spawnTimes) > 0 && First Of(Global.spawnTimes) <= 0) || (Count Of(Global.spawnTimes) + Number Of Players(Team 1)
			< Global.numberOfBots)) == True;
	}

	actions
	{
		Call Subroutine(botHeroRandomization);
		If(Count Of(Global.spawnTimes) > 0 && First Of(Global.spawnTimes) <= 0);
			Modify Global Variable(spawnTimes, Remove From Array By Index, 0);
			Wait(0.250, Ignore Condition);
		Else;
			Wait(1, Ignore Condition);
		End;
		Loop If Condition Is True;
		Wait(Last Of(Sorted Array(Global.spawnTimes, Current Array Element)), Restart When True);
		"Reset spawn times array if conditions are not met"
		If(Count Of(Global.spawnTimes) > 0);
			Global.spawnTimes[0] = 0;
		End;
		Loop If Condition Is True;
	}
}

rule("botHeroRandomization")
{
	event
	{
		Subroutine;
		botHeroRandomization;
	}

	actions
	{
		Global.currentBotHeroList = Filtered Array(Global.botHeros, Number Of Heroes(Current Array Element, Team 1) > 0);
		"Determines if count of current different zombie types is less than the maximum amount allowed"
		If(Count Of(Global.currentBotHeroList) < Global.uniqueSkinCap - (Number Of Players(Team 2) <= Number Of Slots(Team 2)
			? Number Of Slots(Team 2) : Number Of Players(Team 2)));
			Global.randVal = Random Real(0, 100);
			Global.botCurrentSpawnRate = 0;
			Global.botRespawnCount = -1;
			While(Global.randVal > Global.botCurrentSpawnRate || Global.botRespawnCount < 0);
				Global.botRespawnCount += 1;
				Global.botCurrentSpawnRate += Global.botSpawnRates[Global.botRespawnCount];
			End;
			Create Dummy Bot(Global.botHeros[Global.botRespawnCount], Team 1, -1, Vector(500, 500, 500), Vector(0, 0, 0));
		Else;
			Create Dummy Bot(Last Of(Sorted Array(Global.botHeros, Global.botSpawnRates[Current Array Index])), Team 1, -1, Vector(500, 500,
				500), Vector(0, 0, 0));
		End;
		Global.currentBotHeroList = Empty Array;
	}
}

rule("SPAWN TIME CONTROL")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Count Of(Global.spawnTimes) > 0 || Global.botSpawnPointTimers > 0) == True;
	}

	actions
	{
		If(Count Of(Global.spawnTimes) > 0);
			Global.spawnTimes = Sorted Array(Mapped Array(Global.spawnTimes, Current Array Element - 1), Current Array Element);
		End;
		If(Count Of(Global.botSpawnPointTimers) > 0);
			Global.botSpawnPointTimers = Mapped Array(Global.botSpawnPointTimers, Max(0, Current Array Element - 1));
		End;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("START GAME IF WAITING FOR PLAYERS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Waiting For Players == True;
	}

	actions
	{
		Start Game Mode;
		Small Message(Host Player, Custom String("Starting"));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SKIP ASSEMBLING HEROES")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Is Assembling Heroes || (Global.specialGameModeSetup && Count Of(Filtered Array(All Players(Team 2),
			Current Array Element.playerActiveStatus)) == 0)) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Global.voting = True;
		Call Subroutine(enableEnhancements);
		"Set difficulty votes empty"
		Global.difficultyVotes = Array(Array(Null, True), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"),
			Custom String("Beginner"), True, 0)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"),
			Custom String("Normal"), True, 1)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"), Custom String(
			"Expert"), True, 2)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"), Custom String("Legendary"),
			True, 3)), Array(Null, Workshop Setting Toggle(Custom String("Available Difficulties"), Custom String("Insanity"), True, 4)));
		"Set zombie modes empty"
		Global.zombieVotes = Array(Array(Null, True), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"),
			Custom String("Wave 1"), True, 0)), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String(
			"Wave 2"), True, 1)), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String("Wave 3"),
			True, 2)), Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String("Wave 4"), True, 3)),
			Array(Null, Workshop Setting Toggle(Custom String("Available Zombie Modes"), Custom String("Wave 5"), True, 4)));
		"Set/Reset to default 0"
		Global.difficultySetting = 0;
		"Set/Reset to default 0"
		Global.zombieSetting = 0;
		"Set/Reset to default 0"
		If(Is Assembling Heroes);
			Disable Inspector Recording;
			Set Match Time(0);
			Global.specialGameModeSetup = True;
			Wait(0.250, Ignore Condition);
		End;
		Set Match Time(3599);
		Wait Until(Count Of(Filtered Array(All Players(Team 2), Has Spawned(Current Array Element))) > 0 && Count Of(Global.mapGrid) > 0,
			9999);
		Set Match Time(60);
		Wait(0.016, Ignore Condition);
		Global.chase1 = Match Time;
		Chase Global Variable At Rate(chase1, 0, 1, None);
	}
}

rule("VARIABLE ASSIGNMENT")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		If(Current Game Mode == Game Mode(Capture the Flag));
			Global.attackSpawnRooms = First Of(Sorted Array(Spawn Points(Team 1), Distance Between(Current Array Element, Flag Position(
				Team 1))));
		Else If(Current Game Mode == Game Mode(Team Deathmatch));
		Else If(Current Game Mode == Game Mode(Push));
			"Prevent match time from reaching zero due to ws bug with push gamemode"
			Global.matchEndTime = 0.100;
		Else;
			Global.matchEndTime = 0;
		End;
		"Determines if current game mode is base or arcade"
		Global.specialGameMode = Array Contains(Array(Game Mode(Team Deathmatch), Game Mode(Capture the Flag), Game Mode(Push), Game Mode(
			Control)), Current Game Mode) ? True : False;
		Global.wordsOfEncouragement = Array(Custom String("Galatians 6:9"), Custom String("Romans 12:9-10"), Custom String("1 John 1:9"),
			Custom String("Proverbs 17:17"), Custom String("Psalm 42:5"), Custom String("Ephesians 4:32"), Custom String("Hebrews 12:11"));
		"Total amount of powerups"
		Global.availablePowerups = 11;
		Global.amountPerResource = 100 / (Current Game Mode != Game Mode(Team Deathmatch) ? 5 : 5.900);
		"Initial extraction zone radius"
		Global.extractionZoneRad = 300;
		Global.objectiveResourcePositions = Empty Array;
		Global.votingEndTime = 30;
		"Relative center of the map"
		While(Global.walkCenter == Null);
			Wait(1, Ignore Condition);
			Global.walkCenter = (Nearest Walkable Position(Vector(999, 999, 999)) + Nearest Walkable Position(Vector(-999, -999, -999))) / 2;
			Small Message(All Players(All Teams), Custom String("Loading..."));
		End;
		If(Current Game Mode == Game Mode(Control));
			Global.walkCenter = Objective Position(Objective Index);
		End;
		Start Rule(generateMapGrid, Do Nothing);
		Global.objectiveValue = 0;
		Global.objectiveEntities = Empty Array;
		Global.botSpawnPoints = Empty Array;
		Global.waypoints = Empty Array;
		Global.botSpawnPointTimers = Empty Array;
		Global.bosses = Empty Array;
		Global.healthpackPositions = Empty Array;
		Global.overtime = False;
		Global.gameStatus = False;
		"Heros that can be considered invisible due to the nature of some of their character abilities"
		Global.invisibilityHeros = Array(Hero(Sombra), Hero(Moira), Hero(Doomfist), Hero(Tracer));
		Global.users = Empty Array;
		Global.globalPlayerStats = Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
		Global.objectivePositions = Empty Array;
		Global.objectiveTypes = Empty Array;
		Global.objectiveRad = 10;
		Global.reviveRadius = 5;
		Global.mustReviveTime = 60;
		Global.playersOnObjective = Empty Array;
		Global.losList = Empty Array;
		Global.botMaxTeleportRange = Array(20, 30);
		Global.supplyDropStatus = True;
		Global.supplyDropLanding = Null;
		Global.supplyDropPosition = Null;
		Global.powerUpIDs = Empty Array;
		Global.powerUpPositions = Empty Array;
		Global.powerUpEffect = Empty Array;
		Global.powerUpText = Empty Array;
		Global.playerTargetList = Empty Array;
		Global.availableBosses = Empty Array;
		Global.spawnTimes = Empty Array;
		Global.customTelePositions = Empty Array;
		Global.losHeightCheck = 1.200;
		Call Subroutine(enablePowerups);
		Call Subroutine(enableMutations);
		Global.numberOfPowerUpsPerSupplyDrop = Workshop Setting Integer(Custom String("Power Ups"), Custom String(
			"Number of Powerups Per Supply Drop"), 5, 1, 10, -1);
		Global.uniqueSkinCap = Workshop Setting Integer(Custom String("General"), Custom String("Maximum Number of Unique Hero Skins"), 11,
			1, 11, 0);
		Global.objectiveComplete = False;
		Global.numberOfBots = Workshop Setting Integer(Custom String("General"), Custom String("Number of zombies"), 6, 1, 23, 1);
	}
}

rule("START GAME")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != False;
	}

	actions
	{
		Pause Match Time;
		Global.walkCenter = Nearest Walkable Position(Global.walkCenter);
		Global.specialGameModeSetup = False;
		Enable Built-In Game Mode Music;
		Disable Inspector Recording;
		disabled Enable Inspector Recording;
		Destroy All Dummy Bots;
		Destroy All Effects;
		Destroy All HUD Text;
		Destroy All Icons;
		Destroy All In-World Text;
		Wait(0.250, Ignore Condition);
		Set Match Time(Global.startTime + Global.matchEndTime);
		Unpause Match Time;
	}
}

rule("generateMapGrid")
{
	event
	{
		Subroutine;
		generateMapGrid;
	}

	actions
	{
		Global.mapGrid = Empty Array;
		While(Count Of(Global.mapGrid) < 900);
			Global.testPos = Nearest Walkable Position((Count Of(Global.mapGrid) > 5 ? Random Value In Array(Global.mapGrid)
				: Global.walkCenter) + Direction From Angles(Random Real(0, 360), Random Real(-35, 35)) * Random Real(10, 100));
			"Do not grid points inside spawn rooms on CTF maps"
			If((Current Game Mode != Game Mode(Capture the Flag) && Current Game Mode != Game Mode(Push) && Current Game Mode != Game Mode(
				Control) && Current Game Mode != Game Mode(Flashpoint)) || (Is True For All(Spawn Points(Team 1), Distance Between(Position Of(
				Current Array Element), Global.testPos) > 50) && Is True For All(Spawn Points(Team 2), Distance Between(Position Of(
				Current Array Element), Global.testPos) > 40)));
				If(Count Of(Global.mapGrid) == 0 || Is True For All(Global.mapGrid, Distance Between(Current Array Element, Global.testPos)
					> 2.500));
					Modify Global Variable(mapGrid, Append To Array, Global.testPos);
				End;
			End;
			If(Global.specialGameModeSetup && Match Time + Global.matchEndTime < 2);
				Break;
			End;
			Wait(0.016, Ignore Condition);
		End;
		"0: Consecutive, 1: Minimum"
		Global.objectiveSpacing = Array(Min(60, Count Of(Global.mapGrid) / 11), Min(30, Count Of(Global.mapGrid) / 20));
	}
}

rule("determineZombieMode")
{
	event
	{
		Subroutine;
		determineZombieMode;
	}

	actions
	{
		Global.zombieSetting = 0;
		For Global Variable(count1, 1, Count Of(Global.zombieVotes), 1);
			If(Global.zombieVotes[Global.count1][1]);
				Global.zombieVotes[Global.count1] = Count Of(Filtered Array(All Players(Team 2),
					Current Array Element.playerActiveStatus && Current Array Element.playerMenuStatus[3] == Global.count1));
			Else;
				Global.zombieVotes[Global.count1] = -1;
			End;
		End;
		Global.averageVote = 0;
		For Global Variable(count1, 1, Count Of(Global.zombieVotes), 1);
			Global.averageVote += Global.zombieVotes[Global.count1] * Global.count1;
		End;
		Global.averageVote /= Count Of(Filtered Array(All Players(Team 2), Current Array Element.playerMenuStatus[2] > 0));
		For Global Variable(count1, 1, Count Of(Global.zombieVotes), 1);
			If(Global.zombieVotes[Global.zombieSetting] < Global.zombieVotes[Global.count1]);
				Global.zombieSetting = Global.count1;
			Else If(Global.zombieVotes[Global.count1] > 0 && Global.zombieVotes[Global.zombieSetting] == Global.zombieVotes[Global.count1]);
				"Pick Zombie mode closest to the average zombie vote"
				If(Absolute Value(Global.zombieSetting - Global.averageVote) > Absolute Value(Global.count1 - Global.averageVote));
					Global.zombieSetting = Global.count1;
				End;
			End;
		End;
		"If all players choose no preference set zombie mode to default"
		If(Global.zombieSetting == 0);
			Global.zombieSetting = 1;
		End;
		Start Rule(determineDifficulty, Restart Rule);
		Start Rule(setZombieMode, Restart Rule);
	}
}

rule("setZombieMode")
{
	event
	{
		Subroutine;
		setZombieMode;
	}

	actions
	{
		"Bot available hero list"
		Global.botHeros = Array(Hero(Reaper), Hero(Junkrat), Hero(TorbjÃ¶rn), Hero(Roadhog), Hero(Reinhardt), Hero(Genji), Hero(Widowmaker),
			Hero(Orisa), Hero(Mercy), Hero(Wrecking Ball), Hero(Moira), Hero(D.Va), Hero(Pharah), Hero(Ramattra), Hero(Sombra));
		"Zombie types without a boss variation"
		Global.nonBossZombies = Array(Hero(Genji), Hero(Widowmaker), Hero(D.Va), Hero(Ramattra));
		"Wave 1"
		If(Global.zombieSetting == 1);
			Global.botSpawnRates = Array(60, 12, 6, 0, 0, 5, 4, 0, 3, 0, 3, 0, 4, 0, 3);
		"Wave 2"
		Else If(Global.zombieSetting == 2);
			Global.botSpawnRates = Array(50, 5, 8, 3, 2, 8, 3, 2, 3, 1, 7, 1, 2, 2, 3);
		"Wave 3"
		Else If(Global.zombieSetting == 3);
			Global.botSpawnRates = Array(5, 7, 13, 3, 2, 20, 8, 5, 3, 5, 15, 3, 5, 3, 3);
		"Wave 4"
		Else If(Global.zombieSetting == 4);
			Global.botSpawnRates = Array(3, 3, 4, 3, 2, 17, 3, 16, 2, 16, 10, 10, 5, 3, 3);
		"Wave 5"
		Else If(Global.zombieSetting == 5);
			Global.botSpawnRates = Array(1, 1, 1, 8, 14, 17, 1, 10, 2, 16, 10, 3, 10, 3, 3);
		End;
		"TESTING ONLY"
		disabled Global.botSpawnRates = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100);
	}
}

rule("determineDifficulty")
{
	event
	{
		Subroutine;
		determineDifficulty;
	}

	actions
	{
		Global.difficultySetting = 0;
		For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
			If(Global.difficultyVotes[Global.count1][1]);
				Global.difficultyVotes[Global.count1] = Count Of(Filtered Array(All Players(Team 2),
					Current Array Element.playerActiveStatus && Current Array Element.playerMenuStatus[2] == Global.count1));
			Else;
				Global.difficultyVotes[Global.count1] = -1;
			End;
		End;
		Global.averageVote = 0;
		For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
			Global.averageVote += Global.difficultyVotes[Global.count1] * Global.count1;
		End;
		Global.averageVote /= Count Of(Filtered Array(All Players(Team 2), Current Array Element.playerMenuStatus[2] > 0));
		For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
			"If difficulty being compared has more votes than current difficulty"
			If(Global.difficultyVotes[Global.difficultySetting] < Global.difficultyVotes[Global.count1]);
				Global.difficultySetting = Global.count1;
			Else If(
					Global.difficultyVotes[Global.count1] > 0 && Global.difficultyVotes[Global.difficultySetting] == Global.difficultyVotes[Global.count1]);
				"Pick difficulty closest to the average difficulty vote"
				If(Absolute Value(Global.difficultySetting - Global.averageVote) > Absolute Value(Global.count1 - Global.averageVote));
					Global.difficultySetting = Global.count1;
				End;
			End;
		End;
		"Default difficulty"
		If(Global.difficultySetting == 0);
			"If all difficulty options are disabled"
			If(Count Of(Filtered Array(Global.difficultyVotes, Current Array Element == -1)) >= Count Of(Global.difficultyVotes) - 1);
				Global.difficultySetting = 2;
			"If normal is disabled, default to easiest difficulty"
			Else If(Global.difficultyVotes[2] == -1);
				For Global Variable(count1, 1, Count Of(Global.difficultyVotes), 1);
					If(Global.difficultyVotes[Global.count1] != -1);
						Global.difficultySetting = Global.count1;
						Break;
					End;
				End;
			"Else set to beginner"
			Else;
				Global.difficultySetting = 1;
			End;
		End;
		Start Rule(setDifficulty, Restart Rule);
	}
}

rule("setDifficulty")
{
	event
	{
		Subroutine;
		setDifficulty;
	}

	actions
	{
		"Difficulty: Beginner"
		If(Global.difficultySetting == 1);
			Global.startTime = 240;
			"Bot Health Values"
			Global.botHealthValues = Array(213, 130, 75, 750, 1250, 100, 110, 500, 125, 450, 100, 400, 200, 250, 100);
			"Bot bite damage"
			Global.biteDamages = Array(5, 2.500, 2, 20, 0, 5, 2, 7.500, 5, 10, 10, 5, 30, 0, 3);
			"Bot bite durations"
			Global.biteDurations = Array(2, 2, 2.500, 2.500, 0, 1.500, 3.500, 2, 2, 1.500, 1, 1, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.550, 0.600, 0.750, 0.400, 0.500, 0.600, 0.300, 0.550, 0.450, 0.500, 0.750, 0.550, 0.400, 0.500,
				0.300);
			"Bot damage dealt"
			Global.damageDealt = Array(8.500, 60, 1, 1, 50, 75, 1, 25, 1, 50, 1, 50, 75, 50, 5);
		"Difficulty: Normal"
		Else If(Global.difficultySetting == 2);
			Global.startTime = 240;
			"Bot Health Values"
			Global.botHealthValues = Array(225, 170, 125, 900, 2000, 140, 140, 700, 160, 650, 135, 600, 275, 400, 150);
			"Bot bite damage"
			Global.biteDamages = Array(5, 2.500, 2, 20, 0, 5, 2, 7.500, 5, 10, 10, 5, 30, 0, 3);
			"Bot bite durations"
			Global.biteDurations = Array(2, 2, 2.500, 2.500, 0, 1.500, 3.500, 2, 2, 1.500, 1, 1, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.850, 0.900, 1, 0.600, 0.700, 0.800, 0.400, 0.750, 0.700, 0.650, 0.900, 0.800, 0.650, 0.700, 0.350);
			"Bot damage dealt"
			Global.damageDealt = Array(8.500, 60, 1, 1, 50, 75, 1, 25, 1, 50, 1, 50, 75, 50, 5);
		"Difficulty: Expert"
		Else If(Global.difficultySetting == 3);
			Global.startTime = 150;
			"Bot Health Values"
			Global.botHealthValues = Array(225, 170, 125, 900, 2000, 140, 140, 700, 160, 650, 135, 600, 275, 400, 150);
			"Bot bite damage"
			Global.biteDamages = Array(25, 15, 20, 65, 0, 20, 17.500, 20, 30, 20, 40, 12.500, 60, 0, 10);
			"Bot bite durations"
			Global.biteDurations = Array(3, 3, 3, 3, 0, 1.500, 4, 2, 2, 2, 1, 1.500, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.850, 0.900, 1, 0.600, 0.700, 0.800, 0.400, 0.750, 0.700, 0.650, 0.900, 0.800, 0.650, 0.700, 0.350);
			"Bot damage dealt"
			Global.damageDealt = Array(125, 125, 50, 50, 150, 175, 50, 150, 50, 150, 1, 90, 75, 100, 75);
		"Difficulty: Legendary"
		Else If(Global.difficultySetting == 4);
			Global.startTime = 150;
			"Bot Health Values"
			Global.botHealthValues = Array(300, 200, 125, 900, 2000, 160, 150, 800, 200, 750, 175, 600, 300, 400, 200);
			"Bot bite damage"
			Global.biteDamages = Array(35, 22, 25, 75, 0, 25, 20, 25, 35, 25, 90, 31, 70, 0, 20);
			"Bot bite durations"
			Global.biteDurations = Array(3, 3, 3, 3, 0, 1.500, 4, 2, 2, 2, 1, 1.500, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(0.900, 0.950, 1, 0.750, 0.850, 0.900, 0.700, 0.800, 0.800, 0.750, 0.900, 0.800, 0.650, 0.700, 0.500);
			"Bot damage dealt"
			Global.damageDealt = Array(150, 150, 100, 100, 200, 225, 100, 200, 100, 175, 50, 175, 100, 150, 150);
		"Difficulty: Insanity"
		Else If(Global.difficultySetting == 5);
			Global.startTime = 90;
			"Bot Health Values"
			Global.botHealthValues = Array(300, 250, 200, 1200, 2500, 200, 250, 1000, 250, 900, 200, 800, 350, 600, 275);
			"Bot bite damage"
			Global.biteDamages = Array(35, 30, 35, 85, 0, 30, 35, 35, 45, 40, 110, 60, 80, 0, 35);
			"Bot bite durations"
			Global.biteDurations = Array(3, 3, 3, 3, 0, 1.500, 4, 2, 2, 2, 1, 1.500, 0, 0, 3);
			"Bot throttle speeds"
			Global.throttleSpeeds = Array(1, 1, 1, 1, 1, 1, 0.99, 1, 1, 1, 1, 1, 1, 1, 1);
			"Bot damage dealt"
			Global.damageDealt = Array(300, 300, 250, 150, 230, 450, 150, 400, 300, 350, 200, 250, 150, 200, 200);
		End;
		Global.voting = False;
		Wait Until(Is Game In Progress && Global.specialGameModeSetup == False, 9999);
		Global.gameStatus = True;
	}
}

rule("enableEnhancements")
{
	event
	{
		Subroutine;
		enableEnhancements;
	}

	actions
	{
		Global.enhancementOptions = Empty Array;
		Global.enhancementOptions[0] = True;
		Global.enhancementOptions[1] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Infection Resistance"), True,
			1);
		Global.enhancementOptions[2] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Scavenger"), True, 2);
		Global.enhancementOptions[3] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Laser Barricade"), True, 3);
		Global.enhancementOptions[4] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Brain Killer"), True, 4);
		Global.enhancementOptions[5] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Pyrotechnic"), True, 5);
		Global.enhancementOptions[6] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Plague Doctor"), True, 6);
		Global.enhancementOptions[7] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Born to Battle"), True, 7);
		Global.enhancementOptions[8] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Kevlar"), True, 8);
		Global.enhancementOptions[9] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Nano Nurse"), True, 9);
		Global.enhancementOptions[10] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("Hitchhiker"), True, 10);
		Global.enhancementOptions[11] = Workshop Setting Toggle(Custom String("Enhancements"), Custom String("P.U.P."), True, 11);
	}
}

disabled rule("============================================== GLOBAL START MENU ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("GLOBAL MENU INITIALIZATION")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Count Of(Global.mapGrid) > 0;
	}

	actions
	{
		Wait(0.016, Abort When False);
	}
}

rule("EFFECTS/TEXTS")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Pre game objective description and match timer"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} | {1}s", Global.voting ? Custom String(
			"Voting will end in {0}s", Round To Integer(Match Time - Global.votingEndTime, Up)) : Custom String("Select your hero"),
			Round To Integer(Match Time, Up)), Top, -1, Color(Gray), Color(Gray), Custom Color(215, 215, 215, 255), Visible To and String,
			Default Visibility);
		"Creator/Game Code Promo"
		Create HUD Text(All Players(All Teams), Null, Null, Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Custom String(
			"Game Code: MEBGG") : Custom String("Game Mode Creator: Mazattack#1183"), Right, 0, Color(White), Color(White), Color(Blue),
			Visible To and String, Visible Always);
		"Discord Promo"
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("Discord Link in the Game Description"), Right, 1, Color(White),
			Color(White), Color(Purple), Visible To and String, Visible Always);
		"Workshop.codes/Github Promo"
		Create HUD Text(All Players(All Teams), Null, Null, Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Custom String(
			"Workshop.codes/MEBGG") : Custom String("github.com/Mazattack1999/zsw-ow"), Right, 2, Color(White), Color(White),
			Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Color(Orange) : Color(Green), Visible To String and Color,
			Visible Always);
		"Workshop.codes/Discord Promo"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus) < 2),
			Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Custom String("workshop.codes/MEBGG") : Custom String(
			"Discord link in the game description"), Update Every Frame(Eye Position(Local Player) + Direction From Angles(Horizontal Facing Angle Of(Local Player), Vertical Facing Angle Of(Local Player) + 20) * 200), 3, Do Not Clip, Visible To Position String and Color,
			Round To Integer(Total Time Elapsed * 0.200, Up) % 2 == 0 ? Color(Orange) : Color(Purple), Visible Never);
		"Words of encouragement"
		Create In-World Text(All Players(All Teams), Custom String("Words of Encouragement: {0}", Random Value In Array(
			Global.wordsOfEncouragement)), Update Every Frame(Eye Position(Local Player) + Direction From Angles(Horizontal Facing Angle Of(Local Player), Vertical Facing Angle Of(Local Player) + 25) * 200), 1.500, Do Not Clip, Visible To and Position, Color(White), Visible Never);
		"Voting options reminder"
		Create In-World Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.playerMenuStatus) == 2),
			Global.voting ? Custom String("Voting options are available in the top left corner of your screen") : Custom String(
			"Voting is complete. See the game settings in the top left corner of your screen."),
			Update Every Frame(Eye Position(Local Player) + Direction From Angles(Horizontal Facing Angle Of(Local Player), Vertical Facing Angle Of(Local Player) + 20) * 200), 2, Do Not Clip, Visible To Position String and Color, Global.voting ? Color(Aqua) : Color(Purple),
			Visible Never);
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 0), Custom String(
			"Difficulty: No Preference"), Null, Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate))), Left,
			0, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Vote difficulty text: Beginner"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 1), Custom String(
			"Difficulty: Beginner"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(
			Ultimate))) : Custom String(""), Left, 0, Color(Green), Color(Green), Color(Green), Visible To and String, Default Visibility);
		"Vote difficulty text: Normal"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 2), Custom String(
			"Difficulty: Normal"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate)))
			: Custom String(""), Left, 0, Color(Yellow), Color(Yellow), Color(Yellow), Visible To and String, Default Visibility);
		"Vote difficulty text: Expert"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 3), Custom String(
			"Difficulty: Expert"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate)))
			: Custom String(""), Left, 0, Color(Orange), Color(Orange), Color(Orange), Visible To and String, Default Visibility);
		"Vote difficulty text: Legendary"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 4), Custom String(
			"Difficulty: Legendary"), Null, Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(
			Ultimate))) : Custom String(""), Left, 0, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
		"Vote difficulty text: Insanity"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[2] == 5),
			Global.specialEffectsTiming ? Global.specialEffectsStrings : Custom String("Difficulty: Insanity"), Null,
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ultimate))) : Custom String(""), Left,
			0, Global.specialEffectsTiming ? Color(White) : Color(Turquoise), Color(White), Global.specialEffectsTiming ? Color(White)
			: Color(Turquoise), Visible To String and Color, Default Visibility);
		"Vote zombie mode text: No preference"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 0), Custom String(
			"Zombie Wave: No Preference"), Null, Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))), Left,
			1, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 1"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 1), Custom String(
			"Wave 1 - The Beginning"), Custom String("Years after the outbreak begins, zombies start developing strange abilities."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Green), Color(White), Color(Green), Visible To and String, Default Visibility);
		"Vote game type text: Wave 2"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 2), Custom String(
			"Wave 2 - Darker Days"), Custom String("As the outbreak continues, zomibes with more powerful abilities appear."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Yellow), Color(White), Color(Yellow), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 3"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 3), Custom String(
			"Wave 3 - Tipping Point"), Custom String("The outbreak reaches its peak when there are few normal zombies left."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Orange), Color(White), Color(Orange), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 4"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 4), Custom String(
			"Wave 4 - Turning Tide"), Custom String("As mankind fights off the hoard, the number of weaker zombies begins to dwindle."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Color(Red), Color(White), Color(Red), Visible To and String, Default Visibility);
		"Vote zombie mode text: Wave 5 - The Final Days"
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerMenuStatus[3] == 5), Custom String(
			"Wave 5 - The Final Days"), Custom String("The outbreak is nearly over. Only the strongest zombies remain."),
			Global.voting ? Custom String("Change Vote (Press [{0}])", Input Binding String(Button(Ability 1))) : Custom String(""), Left,
			1, Global.specialEffectsTiming ? Color(White) : Color(Turquoise), Color(White), Global.specialEffectsTiming ? Color(White)
			: Color(Turquoise), Visible To String and Color, Default Visibility);
		"Enhancement Selection: No Preference"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 0), Custom String(
			"Enhancement: No Preference"), Null, Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))),
			Left, 3, Color(Aqua), Color(Aqua), Color(Aqua), Visible To and String, Default Visibility);
		"Enhancement Selection: Infection Resistance"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 1), Custom String(
			"Enhancement: Infection Resistance {0}", Icon String(Poison 2)), Custom String("Infection level decreases slowly over time"),
			Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Green), Color(Green),
			Color(Green), Visible To and String, Default Visibility);
		"Enhancement Selection: Scavenger"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 2), Custom String(
			"Enhancement: Scavenger {0}", Ability Icon String(Hero Of(Local Player), Button(Primary Fire))), Custom String(
			"Player collects ammunition from zombies they kill"), Custom String("Change Selection (Press [{0}])", Input Binding String(
			Button(Melee))), Left, 3, Color(Gray), Color(Gray), Color(Gray), Visible To and String, Default Visibility);
		"Enhancement Selection: Laser Barricade"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 3), Custom String(
			"Enhancement: Laser Barricade {0}", Ability Icon String(Hero(Reinhardt), Button(Secondary Fire))), Custom String(
			"Player can place a wall that blocks zombies"), Custom String("Change Selection (Press [{0}])", Input Binding String(Button(
			Melee))), Left, 3, Color(Blue), Color(Blue), Color(Blue), Visible To and String, Default Visibility);
		"Enhancement Selection: Brain Killer"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 4), Custom String(
			"Enhancement: Brain Killer {0}", Icon String(Skull)), Custom String("Critical hits do more damage"), Custom String(
			"Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Red), Color(Red), Color(Red),
			Visible To and String, Default Visibility);
		"Enhancement Selection: Pyrotechnic"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 5), Custom String(
			"Enhancement: Pyrotechnic {0}", Icon String(Fire)), Custom String("Dealing damage, at close range, sets enemies on fire"),
			Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Orange), Color(Orange),
			Color(Orange), Visible To and String, Default Visibility);
		"Enhancement Selection: Plague Doctor"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 6), Custom String(
			"Enhancement: Plague Doctor {0}", Icon String(Plus)), Custom String(
			"Deal more healing to infected players while reducing their infection level"), Custom String("Change Selection (Press [{0}])",
			Input Binding String(Button(Melee))), Left, 3, Color(Green), Color(Green), Color(Green), Visible To and String,
			Default Visibility);
		"Enhancement Selection: Born to Battle"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 7), Custom String(
			"Enhancement: Born to Battle {0}", Icon String(Bolt)), Custom String(
			"Dealing a final blow will give the player a cooldown reset on the next ability they use"), Custom String(
			"Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Gray), Color(Gray), Color(Gray),
			Visible To and String, Default Visibility);
		"Enhancement Selection: Kevlar"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 8), Custom String(
			"Enhancement: Kevlar {0}", Icon String(Stop)), Custom String(
			"Survivor is equipped with armor that protects against infectious bites"), Custom String("Change Selection (Press [{0}])",
			Input Binding String(Button(Melee))), Left, 3, Custom Color(240, 129, 26, 255), Custom Color(240, 129, 26, 255), Custom Color(
			240, 129, 26, 255), Visible To and String, Default Visibility);
		"Enhancement Selection: Nano Nurse"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 9), Custom String(
			"Enhancement: Nano Nurse {0}", Icon String(Plus)), Custom String(
			"Survivor is infused with nano technology that regenerates health after taking damage "), Custom String(
			"Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Yellow), Color(Yellow), Color(Yellow),
			Visible To and String, Default Visibility);
		"Enhancement Selection: Hitchhiker"
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 10), Custom String(
			"Enhancement: Hitchhiker {0}", Ability Icon String(Hero(Zenyatta), Button(Ultimate))), Custom String(
			"Survivor can ride on the backs of their teammates"), Custom String("Change Selection (Press [{0}])", Input Binding String(
			Button(Melee))), Left, 3, Color(Purple), Color(Purple), Color(Purple), Visible To and String, Default Visibility);
		"Enhancement Selection: P.U.P."
		Create HUD Text(Filtered Array(All Players(All Teams), First Of(Current Array Element.enhancementValues) == 11), Custom String(
			"Enhancement: P.U.P. {0}", Icon String(Happy)), Custom String("Survivor is equipped with an autonomous friendly droid"),
			Custom String("Change Selection (Press [{0}])", Input Binding String(Button(Melee))), Left, 3, Color(Blue), Color(Blue), Color(
			Blue), Visible To and String, Default Visibility);
	}
}

rule("SPECIAL EFFECT CONTROLS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.difficultySetting >= 5 || Global.specialGameModeSetup) == True;
	}

	actions
	{
		If(Global.specialGameModeSetup);
			Global.randVal = Random Integer(1, 6);
			If(Global.randVal == 1);
				Global.specialEffectsStrings = Custom String("fiiDultyc oteV: saInntyi");
			Else If(Global.randVal == 2);
				Global.specialEffectsStrings = Custom String("Your time has come");
			Else If(Global.randVal == 3);
				Global.specialEffectsStrings = Custom String("You will die");
			Else If(Global.randVal == 4);
				Global.specialEffectsStrings = Custom String("You won't win");
			Else If(Global.randVal == 5);
				Global.specialEffectsStrings = Custom String("Don't even try it");
			Else If(Global.randVal == 6);
				Global.specialEffectsStrings = Custom String("Your funeral...");
			End;
		End;
		Global.specialEffectsTiming = True;
		Wait(Random Real(0.063, 0.325), Abort When False);
		Global.specialEffectsTiming = False;
		Wait(Random Real(0.325, 1.500), Abort When False);
		Loop;
	}
}

rule("END VOTING")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Match Time < Global.votingEndTime;
		Count Of(Filtered Array(All Players(Team 2), Current Array Element.playerMenuStatus[0] > 0)) > 0;
	}

	actions
	{
		Global.chase1 = Global.votingEndTime;
		Start Rule(determineZombieMode, Restart Rule);
		"Waits until votes have been counted"
		Wait Until(!Global.voting, 99999);
		All Players(Team 2).playerMenuStatus[2] = Global.difficultySetting;
		All Players(Team 2).playerMenuStatus[3] = Global.zombieSetting;
		All Players(Team 2).playerMenuStatus[4] = Global.objectiveTypeSetting;
		Big Message(All Players(All Teams), Custom String("Voting has ended!"));
		Start Rule(setPrematchTimer, Restart Rule);
	}
}

rule("setPrematchTimer")
{
	event
	{
		Subroutine;
		setPrematchTimer;
	}

	actions
	{
		"Cancel if hidden timer has not been set"
		Abort If(!Global.chase1);
		"Voting in progress"
		If(Global.voting);
			"Event player is voting"
			If(Event Player.playerMenuStatus[1] == 1);
				"Set match time to hidden timer"
				Set Match Time(Global.chase1);
			"Event Player is not voting"
			Else;
				"All players are finished voting"
				If(Match Time > 5 + Global.votingEndTime && Count Of(Filtered Array(All Players(Team 2),
					Current Array Element.playerMenuStatus[1] == 0 && First Of(Current Array Element.playerMenuStatus) > 0)) == Number Of Players(
					Team 2));
					Set Match Time(5 + Global.votingEndTime);
				Else If(Match Time > 20 + Global.votingEndTime && Count Of(Filtered Array(All Players(Team 2),
						Current Array Element.playerMenuStatus[1] == 0 && First Of(Current Array Element.playerMenuStatus) > 0)) == Count Of(
						Filtered Array(All Players(Team 2), Current Array Element.playerActiveStatus)));
					Set Match Time(20 + Global.votingEndTime);
				End;
			End;
		"Voting complete"
		Else;
			"Event Player deselects hero"
			If(Event Player.playerMenuStatus[0] < 2);
				Set Match Time(Global.chase1);
			Else;
				If(Match Time > 10 && Count Of(Filtered Array(All Players(Team 2), First Of(Current Array Element.playerMenuStatus) == 2))
					== Number Of Players(Team 2));
					Set Match Time(15);
					Wait(0.016, Ignore Condition);
					Set Match Time(10);
				Else If(Match Time > 20 && Count Of(Filtered Array(All Players(Team 2), First Of(Current Array Element.playerMenuStatus) == 2))
						== Count Of(Filtered Array(All Players(Team 2), Current Array Element.playerActiveStatus)));
					Set Match Time(20);
				End;
			End;
	}
}

rule("MUSIC/ANNOUNCER CONTROL")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.voting != True;
		Global.specialGameModeSetup == True;
	}

	actions
	{
		If(Match Time < 20);
			Enable Built-In Game Mode Music;
			Enable Built-In Game Mode Announcer;
			Wait Until(Match Time > 20 || !Global.specialGameModeSetup, 60);
		Else;
			Disable Built-In Game Mode Music;
			Disable Built-In Game Mode Announcer;
			Wait Until(Match Time < 20 || !Global.specialGameModeSetup, 60);
		End;
		Loop If Condition Is True;
	}
}

disabled rule("============================================== PLAYER START MENU ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYER MENU INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Disable Game Mode In-World UI(Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.enhancementValues[0] = 0;
		If(Global.voting);
			"0) Hero Selection Status, 1) Voting Status, 2) Difficulty Vote, 3) Zombie Vote, 4) Objective Type Vote"
			Event Player.playerMenuStatus = Array(0, 0, 0, 0);
		Else;
			"0) Hero Selection Status, 1) Voting Status, 2) Difficulty Vote, 3) Zombie Vote, 4) Objective Type Vote"
			Event Player.playerMenuStatus[2] = Global.difficultySetting;
			Event Player.playerMenuStatus[3] = Global.zombieSetting;
			Event Player.playerMenuStatus[4] = Global.objectiveTypeSetting;
		End;
		Call Subroutine(enableDisableAbilities);
	}
}

rule("PLAYER SELECTS/RESELECTS HERO")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Event Player.playerMenuStatus[0] == 0;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Start Rule(setPrematchTimer, Restart Rule);
		Event Player.playerMenuStatus[0] = 2;
		Wait(0.016, Ignore Condition);
		If(!Event Player.playerActiveStatus);
			Small Message(Event Player, Custom String(
				"Use the voting options in the top left corner of your screen to adjust the game settings"));
			Event Player.playerActiveStatus = True;
		End;
		Loop If Condition Is True;
	}
}

rule("PLAYER MENU CONTROLS (ULTIMATE, DIFFICULTY VOTE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		"Update player voting status"
		Event Player.playerMenuStatus[1] = 1;
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(Event Player.playerMenuStatus[2] < Count Of(Global.difficultyVotes) - 1);
				Event Player.playerMenuStatus[2] += 1;
			Else;
				Event Player.playerMenuStatus[2] = 0;
			End;
			While(!Global.difficultyVotes[Event Player.playerMenuStatus[2]][1]);
				If(Event Player.playerMenuStatus[2] < Count Of(Global.difficultyVotes) - 1);
					Event Player.playerMenuStatus[2] += 1;
				Else;
					Event Player.playerMenuStatus[2] = 0;
				End;
			End;
		Else;
			If(Event Player.playerMenuStatus[2] > 0);
				Event Player.playerMenuStatus[2] += -1;
			Else;
				Event Player.playerMenuStatus[2] = Count Of(Global.difficultyVotes) - 1;
			End;
			While(!Global.difficultyVotes[Event Player.playerMenuStatus[2]][1]);
				If(Event Player.playerMenuStatus[2] > 0);
					Event Player.playerMenuStatus[2] += -1;
				Else;
					Event Player.playerMenuStatus[2] = Count Of(Global.difficultyVotes) - 1;
				End;
			End;
	}
}

rule("PLAYER MENU CONTROLS (ABILITY 1, ZOMBIE VOTE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.voting == True;
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		"Update player voting status"
		Event Player.playerMenuStatus[1] = 1;
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(Event Player.playerMenuStatus[3] < Count Of(Global.zombieVotes) - 1);
				Event Player.playerMenuStatus[3] += 1;
			Else;
				Event Player.playerMenuStatus[3] = 0;
			End;
			While(!Global.zombieVotes[Event Player.playerMenuStatus[3]][1]);
				If(Event Player.playerMenuStatus[3] < Count Of(Global.zombieVotes) - 1);
					Event Player.playerMenuStatus[3] += 1;
				Else;
					Event Player.playerMenuStatus[3] = 0;
				End;
			End;
		Else;
			If(Event Player.playerMenuStatus[3] > 0);
				Event Player.playerMenuStatus[3] += -1;
			Else;
				Event Player.playerMenuStatus[3] = Count Of(Global.zombieVotes) - 1;
			End;
			While(!Global.zombieVotes[Event Player.playerMenuStatus[3]][1]);
				If(Event Player.playerMenuStatus[3] > 0);
					Event Player.playerMenuStatus[3] += -1;
				Else;
					Event Player.playerMenuStatus[3] = Count Of(Global.zombieVotes) - 1;
				End;
			End;
	}
}

rule("PLAYER MENU CONTROLS (MELEE , ENHANCEMENT SELECTION)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		If(!Is Button Held(Event Player, Button(Secondary Fire)));
			If(First Of(Event Player.enhancementValues) < Count Of(Global.enhancementOptions) - 1);
				Event Player.enhancementValues[0] += 1;
			Else;
				Event Player.enhancementValues[0] = 0;
			End;
			While(!Global.enhancementOptions[First Of(Event Player.enhancementValues)]);
				If(First Of(Event Player.enhancementValues) < Count Of(Global.enhancementOptions) - 1);
					Event Player.enhancementValues[0] += 1;
				Else;
					Event Player.enhancementValues[0] = 0;
				End;
			End;
		Else;
			If(First Of(Event Player.enhancementValues) > 0);
				Event Player.enhancementValues[0] += -1;
			Else;
				Event Player.enhancementValues[0] = Count Of(Global.enhancementOptions) - 1;
			End;
			While(!Global.enhancementOptions[First Of(Event Player.enhancementValues)]);
				If(First Of(Event Player.enhancementValues) > 0);
					Event Player.enhancementValues[0] += -1;
				Else;
					Event Player.enhancementValues[0] = Count Of(Global.enhancementOptions) - 1;
				End;
			End;
	}
}

rule("UPDATE PREGAME VOTING STATUS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup == True;
		Event Player.playerMenuStatus[1] == 1;
		Is Button Held(Event Player, Button(Ultimate)) == False;
		Is Button Held(Event Player, Button(Ability 1)) == False;
	}

	actions
	{
		Start Rule(setPrematchTimer, Restart Rule);
		Wait(2, Abort When False);
		Event Player.playerMenuStatus[1] = 0;
		Start Rule(setPrematchTimer, Restart Rule);
	}
}

rule("enableDisableAbilities")
{
	event
	{
		Subroutine;
		enableDisableAbilities;
	}

	actions
	{
		If(Global.specialGameModeSetup);
			Disable Hero HUD(Event Player);
			Set Primary Fire Enabled(Event Player, False);
			Set Secondary Fire Enabled(Event Player, False);
			Set Ability 1 Enabled(Event Player, False);
			Set Ability 2 Enabled(Event Player, False);
			Set Ultimate Ability Enabled(Event Player, False);
			Set Melee Enabled(Event Player, False);
		Else;
			Set Primary Fire Enabled(Event Player, True);
			Set Secondary Fire Enabled(Event Player, True);
			Set Ability 1 Enabled(Event Player, True);
			Set Ability 2 Enabled(Event Player, True);
			Set Ultimate Ability Enabled(Event Player, True);
			Set Melee Enabled(Event Player, True);
			Enable Hero HUD(Event Player);
		End;
	}
}

disabled rule("============================================== GLOBAL GAME IN PROGRESS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("EFFECTS/TEXTS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != True;
	}

	actions
	{
		Wait(1, Ignore Condition);
		"Infected Hud"
		Create HUD Text(Filtered Array(All Players(All Teams), (Count Of(Global.healthpackPositions) == 0 || Health(Current Array Element)
			< Round To Integer(Current Array Element.infectionLvl, Down) ^ 4 / 16 * 20)
			&& Current Array Element.infected && Match Time > Global.matchEndTime), Custom String("{0} Find a healthpack {0}", Icon String(
			Plus)), Null, Null, Right, 0, Round To Integer(Total Time Elapsed * 2, Up) % 2 == 0 ? (Health(Local Player) < Round To Integer(
			Local Player.infectionLvl, Down) ^ 4 / 16 * 10 ? Color(Red) : Color(Lime Green)) : Color(White), Color(White), Color(White),
			Visible To and Color, Default Visibility);
		"Nearest Healthpack Distance"
		Create In-World Text(Filtered Array(All Players(Team 2), Count Of(Global.healthpackPositions)
			> 0 && Current Array Element.infected && Match Time > Global.matchEndTime), Custom String("Cure: {0}m", Distance Between(
			Position Of(Local Player), First Of(Sorted Array(Global.healthpackPositions, Angle Between Vectors(Facing Direction Of(
			Local Player), Direction Towards(Eye Position(Local Player), Current Array Element)))))), First Of(Sorted Array(
			Global.healthpackPositions, Angle Between Vectors(Facing Direction Of(Local Player), Direction Towards(Eye Position(
			Local Player), Current Array Element)))), 1, Do Not Clip, Visible To Position and String, Color(Green), Visible Never);
		"Nearest health pack icon"
		Create Icon(Filtered Array(All Players(Team 2), Count Of(Global.healthpackPositions)
			> 0 && Current Array Element.infected && Match Time > Global.matchEndTime), First Of(Sorted Array(Global.healthpackPositions,
			Angle Between Vectors(Facing Direction Of(Local Player), Direction Towards(Eye Position(Local Player),
			Current Array Element)))) + Vector(0, 0.750, 0) + Vector(0, 0.500 * Sine From Radians(Match Time * 1.500), 0), Poison,
			Visible To and Position, Color(Green), True);
		"SERVER LOAD"
		Create HUD Text(String Contains(Custom String("{0}", Local Player), Custom String("Mazattack")) ? Local Player : Empty Array,
			Custom String("Spawn Array: {0}, {1}, {2}", Global.spawnTimes[0], Global.spawnTimes[1],  Global.spawnTimes[2]), Custom String(
			"SERVER LOAD AVERAGE: {0}", Server Load Average), Custom String("SERVER LOAD PEAK: {0}", Server Load Peak), Right, 0, Color(
			White), Color(White), Color(White), Visible To and String, Default Visibility);
		If(Global.difficultySetting == 1);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Beginner | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Green), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 2);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Normal | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Yellow), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 3);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Expert | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Orange), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 4);
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Legendary | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Color(Red), Visible To, Default Visibility);
		Else If(Global.difficultySetting == 5);
			"Vote text: Insanity"
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("Difficulty: Insanity | Wave {0}", Global.zombieSetting), Right,
				0.100, Color(White), Color(White), Global.specialEffectsTiming ? Color(White) : Color(Turquoise), Visible To and Color,
				Default Visibility);
		End;
	}
}

rule("PLAYER EXTRACTION CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Array Contains(Global.evacuatingSurvivorList, Event Player) == True;
	}

	actions
	{
		Event Player.chase2 = Position Of(Event Player);
		Chase Player Variable At Rate(Event Player, chase2, Event Player.chase2 + Vector(0, 200, 0), Global.evacRate,
			Destination and Rate);
		Start Forcing Player Position(Event Player, Event Player.chase2, True);
		Wait Until(Global.evacRate > 2, 99999);
		Chase Player Variable Over Time(Event Player, chase2, First Of(Global.objectivePositions) + Vector(0, 50, 0)
			+ Direction From Angles(360 / Count Of(Global.evacuatingSurvivorList) * Index Of Array Value(Global.evacuatingSurvivorList,
			Event Player), 0) * 3, 5, Destination and Duration);
		Wait Until(Global.evacRate < 10, 99999);
		Chase Player Variable At Rate(Event Player, chase2, Event Player.chase2 + Vector(0, 200, 0), Global.evacRate,
			Destination and Rate);
		Event Player.evacPos = Event Player.chase2 + Direction Towards(First Of(Global.objectivePositions), Global.evacDestination) * 700;
		Wait Until(Global.evacRate > 2, 99999);
		Chase Player Variable At Rate(Event Player, chase2, Event Player.evacPos, Global.evacRate, Destination and Rate);
	}
}

disabled rule("PREVENT MATCH TIME FROM UNPAUSING")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Match Time < Global.matchEndTime;
	}

	actions
	{
		Pause Match Time;
		Set Match Time(Global.matchEndTime);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

disabled rule("TRIGGER OVERTIME MUSIC")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Global.overtime == False;
		Match Time < Global.matchEndTime + 3;
		Count Of(Filtered Array(All Living Players(Team 1), Current Array Element.botTarget == Null && !Array Contains(Global.bosses,
			Current Array Element))) > 0;
	}

	actions
	{
		If(!Global.specialGameMode);
			Global.overtime = True;
			If(Current Game Mode == Game Mode(Escort));
				Teleport(First Of(Filtered Array(All Living Players(Team 1), Current Array Element.botTarget == Null && !Array Contains(
					Global.bosses, Current Array Element))), Payload Position);
			Else;
				Teleport(First Of(Filtered Array(All Living Players(Team 1), Current Array Element.botTarget == Null && !Array Contains(
					Global.bosses, Current Array Element))), Objective Position(0));
			End;
		End;
	}
}

rule("PLAYER LEAVES THE GAME")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	conditions
	{
		(Is True For Any(Global.playerTargetList, !Entity Exists(Current Array Element)) || Is True For Any(Global.playersOnObjective,
			!Entity Exists(Current Array Element))) == True;
	}

	actions
	{
		Modify Global Variable(playerTargetList, Remove From Array By Value, Filtered Array(Global.playerTargetList, !Entity Exists(
			Current Array Element)));
		Modify Global Variable(playersOnObjective, Remove From Array By Value, Filtered Array(Global.playersOnObjective, !Entity Exists(
			Current Array Element)));
		Wait(1, Restart When True);
		Loop If Condition Is True;
	}
}

rule("nukeMap")
{
	event
	{
		Subroutine;
		nukeMap;
	}

	actions
	{
		Set Match Time(60);
		Unpause Match Time;
		Stop Chasing Global Variable(chase1);
		Global.chase1 = Global.walkCenter + Direction From Angles(Random Integer(0, 359), Random Real(-45, -60)) * 500;
		Wait(0.016, Ignore Condition);
		Chase Global Variable Over Time(chase1, Global.walkCenter, 5, Destination and Duration);
		While(Distance Between(Global.chase1, Global.walkCenter) > 1);
			Play Effect(All Players(All Teams), Good Explosion, Color(Sky Blue), Global.chase1, 3);
			Wait(0.016, Ignore Condition);
		End;
		For Global Variable(count2, 0, 400, 1);
			Play Effect(All Players(All Teams), Bad Explosion, Custom Color(255, Random Real(100, 255), 0, 255),
				Global.walkCenter + Direction From Angles(Random Real(0, 360), 0) * Random Integer(0, (Global.count2 / 20) ^ 2 + 1), (
				Global.count2 / 18) ^ 2);
			Wait(0.016, Ignore Condition);
		End;
	}
}

disabled rule("============================================== OBJECTIVE TYPE: EXTRACTION POINT =============================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYERS IN EXTRACTION POINT CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.objectiveComplete == False;
		Global.gameStatus == True;
		Has Spawned(Event Player) == True;
		First Of(Global.objectiveTypes) == 1;
		Count Of(Global.objectivePositions) == 1;
		Y Component Of(First Of(Global.objectivePositions)) - Y Component Of(Eye Position(Event Player)) < 2;
		Distance Between(Position Of(Event Player), Vector(X Component Of(First Of(Global.objectivePositions)), Y Component Of(Position Of(
			Event Player)), Z Component Of(First Of(Global.objectivePositions)))) < Global.objectiveRad;
	}

	actions
	{
		If(!Array Contains(Global.playersOnObjective, Event Player));
			Modify Global Variable(playersOnObjective, Append To Array, Event Player);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
		If(Global.gameStatus);
			Modify Global Variable(playersOnObjective, Remove From Array By Value, Event Player);
	}
}

rule("EXTRACTION ZONE INFECTION INCREASE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Is Alive(Event Player) == True;
		Count Of(Global.objectivePositions) == 1;
		Global.extractionZoneRad < 200;
		Distance Between(First Of(Global.objectivePositions), Position Of(Event Player)) > Global.extractionZoneRad;
		Array Contains(Global.playersOnObjective, Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Event Player.infectionLvl += 1;
		If(!Event Player.infected && Event Player.infectionLvl >= 1);
			Event Player.infected = True;
		End;
		"Kick players out of the spawn room if dome is closing in."
		While(Is In Spawn Room(Event Player));
			Teleport(Event Player, Nearest Walkable Position(Position Of(Event Player) + Direction Towards(Position Of(Event Player), First Of(
				Global.objectivePositions)) * 10));
			Wait(0.125, Ignore Condition);
		End;
		Loop;
	}
}

disabled rule("============================================== PLAYERS GAME IN PROGRESS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYER INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != True;
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Event Player.movementSpeed = 1;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Event Player.attached = False;
		Event Player.blinded = False;
		Event Player.afk = False;
		Wait(0.250, Abort When False);
		Enable Game Mode In-World UI(Event Player);
		Enable Game Mode HUD(Event Player);
		Event Player.invisible = False;
		Event Player.reviving = False;
		Event Player.infected = False;
		Enable Death Spectate Target HUD(Event Player);
		Event Player.reviveStartTime = 5;
		Event Player.reviveTimer = Event Player.reviveStartTime;
		Event Player.deathTimer = Global.mustReviveTime;
		Event Player.initialMaxHealth = Max Health(Event Player);
		Event Player.infectionLvl = 0;
		Call Subroutine(enableDisableAbilities);
		Event Player.size = 1;
		"Player joins midgame"
		If(First Of(Event Player.playerMenuStatus) == 0 && False);
			"Player joins game fo the first time"
			If(!Array Contains(Global.users, Custom String("{0}", Event Player)));
				Call Subroutine(updateUsers);
				Teleport(Event Player, Nearest Walkable Position(Position Of(First Of(Sorted Array(Remove From Array(Global.playerTargetList,
					Event Player), Distance Between(Position Of(Current Array Element), First Of(Global.objectivePositions)))))));
				Set Status(Event Player, Null, Invincible, 10);
				Small Message(Event Player, Custom String("Help your teammates with completing objectives"));
				Event Player.playerActiveStatus = True;
			"Player rejoins game after having left"
			Else;
				"Index of user in user array"
				Event Player.userIndex = Index Of Array Value(Global.users, Custom String("{0}", Event Player));
				Event Player.deathTimer = Global.globalPlayerStats[Event Player.userIndex][1];
				Event Player.reviveTimer = Global.globalPlayerStats[Event Player.userIndex][2];
				Event Player.reviveStartTime = Global.globalPlayerStats[Event Player.userIndex][3];
				"Player was alive when they left"
				If(First Of(Global.globalPlayerStats[Event Player.userIndex]) == 0);
					Teleport(Event Player, Nearest Walkable Position(Position Of(First Of(Sorted Array(Remove From Array(Global.playerTargetList,
						Event Player), Distance Between(Position Of(Current Array Element), First Of(Global.objectivePositions)))))));
					Set Status(Event Player, Null, Phased Out, 10);
					Small Message(Event Player, Custom String("Help your teammates with completing objectives"));
					Event Player.playerActiveStatus = True;
				"Player was downed when they left"
				Else If(First Of(Global.globalPlayerStats[Event Player.userIndex]) == 1);
					Teleport(Event Player, Global.globalPlayerStats[Event Player.userIndex][4]);
					While(Is Alive(Event Player));
						Kill(Event Player, Null);
						Wait(0.500, Ignore Condition);
					End;
					Event Player.playerActiveStatus = True;
					Big Message(Event Player, Custom String("You are downed"));
					Wait(0.500, Ignore Condition);
					Small Message(Event Player, Custom String("Wait for a teammate to revive you"));
				"Player was dead when they left"
				Else If(First Of(Global.globalPlayerStats[Event Player.userIndex]) == 2);
					Event Player.playerActiveStatus = False;
					Teleport(Event Player, Global.globalPlayerStats[Event Player.userIndex][4]);
					Big Message(Event Player, Custom String("You are dead"));
					Wait(0.500, Ignore Condition);
					Small Message(Event Player, Custom String("Please wait for the next round to begin"));
					Set Invisible(Event Player, All);
				End;
			End;
		"Player joined on start screen"
		Else;
			Event Player.playerActiveStatus = True;
			Call Subroutine(updateUsers);
		End;
	}
}

rule("EFFECTS/TEXTS")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Event Player.playerActiveStatus == True;
		Has Spawned(Event Player) == True;
		Global.specialGameModeSetup != True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		"Infected aura"
		Create Effect(Filtered Array(All Players(All Teams), Event Player.infected), Bad Aura, Color(Lime Green), Event Player,
			Local Player == Event Player ? 0.100 : 0.500, Visible To Position and Radius);
		"Health Hud text"
		Create HUD Text(Filtered Array(All Players(All Teams), Event Player.deathTimer > 0 && !Event Player.afk), Custom String(
			"{0}{1}: {2}", Event Player, Hero Icon String(Hero Of(Event Player)), Is Alive(Event Player) ? Custom String("{0}%",
			Round To Integer(Normalized Health(Event Player) * 100, Up)) : Custom String("DOWN")), Is Dead(Event Player)
			&& !Event Player.reviving ? Custom String("", Round To Integer(Event Player.deathTimer, Up)) : Custom String(""),
			Event Player.infectionLvl >= 1 ? Custom String("Infection Level: {0}", Round To Integer(Event Player.infectionLvl, Down)) : (
			Event Player.infectionLvl < 0 ? Custom String("Vaccine Level: {0}", Absolute Value(Round To Integer(Event Player.infectionLvl,
			Down))) : (Event Player.reviving ? Custom String("Reviving: {0}s", Round To Integer(Event Player.reviveTimer, Up))
			: Custom String(""))), Left, Normalized Health(Event Player) > 0.970 ? 0 : 1 / (Normalized Health(Event Player) + 1),
			Normalized Health(Event Player) > 0.970 ? Color(Blue) : (Normalized Health(Event Player) > 0.660 ? Color(Green) : (
			Normalized Health(Event Player) > 0.330 ? Color(Yellow) : (Normalized Health(Event Player) > 0 ? Color(Orange) : Color(Red)))),
			Color(Red), Event Player.infectionLvl >= 1 ? Color(Lime Green) : (Event Player.infectionLvl < 0 ? Color(Blue) : Color(Yellow)),
			Visible To Sort Order String and Color, Default Visibility);
	}
}

rule("UPDATE BOT OUTLINE COLORS AND VISIBILITY")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.updateOutlines == True;
	}

	actions
	{
		Event Player.updateOutlines = False;
		Event Player.potentialTargets = All Living Players(Team 1);
		If(Event Player.blinded);
			Start Forcing Player Outlines(Event Player.potentialTargets, Event Player, False, Color(White), Default);
		Else;
			For Player Variable(Event Player, outlineCount, 0, Count Of(Event Player.potentialTargets), 1);
				Event Player.botTarget = Event Player.potentialTargets[Event Player.outlineCount];
				If(Event Player.botTarget.defaultOutlineColor);
					Start Forcing Player Outlines(Event Player.botTarget, Event Player, True, Event Player.botTarget.defaultOutlineColor, Default);
				Else;
					Stop Forcing Player Outlines(Event Player.botTarget, Event Player);
				End;
			End;
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER PICKS UP HEALTH PACK")
{
	event
	{
		Player Received Healing;
		Team 2;
		All;
	}

	conditions
	{
		Event Was Health Pack == True;
	}

	actions
	{
		Start Heal Over Time(Event Player, Null, 5, 20);
		If(Match Time > Global.matchEndTime);
			"Update known health pack positions"
			If(Is True For All(Global.healthpackPositions, Distance Between(Current Array Element, Position Of(Event Player)) > 5));
				Modify Global Variable(healthpackPositions, Append To Array, Position Of(Event Player));
			End;
			Stop All Damage Over Time(Event Player);
			Clear Status(Event Player, Burning);
			If(Event Player.infectionLvl > 0);
				If(Event Player.infected);
					Small Message(Event Player, Custom String("You are cured!"));
					Event Player.infected = False;
				End;
				Event Player.infectionLvl = 0;
			End;
		Else If(Event Player.infected);
			Small Message(Event Player, Custom String("Match time has reached 0. Health packs no longer cure infection."));
		End;
	}
}

rule("PLAYER CLEARS DAMAGE OVER TIME")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Is Dummy Bot(Event Player) == False;
		(Has Status(Event Player, Phased Out) || Has Status(Event Player, Invincible)) == True;
	}

	actions
	{
		Stop All Damage Over Time(Event Player);
		Clear Status(Event Player, Burning);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER INFECTION DAMAGE MANAGEMENT")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.infected == True;
	}

	actions
	{
		If(Event Player.infectionLvl < 1);
			Event Player.infected = False;
		End;
		Start Damage Over Time(Event Player, Null, 1, Round To Integer(Event Player.infectionLvl, Down) ^ 4 / 16);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER AFK")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		Workshop Setting Toggle(Custom String("General"), Custom String("Allow players to go AFK"), True, 3) == True;
		Event Player.playerActiveStatus == True;
		Event Player.attached != True;
		Throttle Of(Event Player) == Vector(0, 0, 0);
		Is Dummy Bot(Event Player) == False;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		Is Firing Primary(Event Player) == False;
		Is Firing Secondary(Event Player) == False;
		Array Contains(Global.playersOnObjective, Event Player) != True;
	}

	actions
	{
		If(!Event Player.afk);
			Wait(30, Abort When False);
			Small Message(Remove From Array(All Players(All Teams), Event Player), Custom String("{0} {1} is afk", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Small Message(Event Player, Custom String("You are afk", Event Player, Hero Icon String(Hero Of(Event Player))));
			Event Player.afk = True;
			Set Invisible(Event Player, All);
			Modify Global Variable(playerTargetList, Remove From Array By Value, Event Player);
			Set Status(Event Player, Null, Phased Out, 9999);
		Else;
			Wait Until(Is Firing Primary(Event Player) || Is Firing Secondary(Event Player), 1);
		End;
		Loop If Condition Is True;
		If(Event Player.afk);
			Event Player.afk = False;
			Set Invisible(Event Player, None);
			Small Message(Remove From Array(All Players(All Teams), Event Player), Custom String("{0} {1} is no longer afk", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Small Message(Event Player, Custom String("You are no longer afk", Event Player, Hero Icon String(Hero Of(Event Player))));
			Clear Status(Event Player, Phased Out);
		End;
	}
}

rule("PLAYER VISIBILITY MANAGMENT")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Event Player.invisible == False;
		(Is Using Ability 1(Event Player) || Is Using Ability 2(Event Player) || Is Using Ultimate(Event Player)) == True;
		Array Contains(Global.invisibilityHeros, Hero Of(Event Player)) == True;
	}

	actions
	{
		"Cases where players will be invisible to bots while using normal game abilities"
		If((Hero Of(Event Player) == Hero(Sombra) || Hero Of(Event Player) == Hero(Moira)) && Is Using Ability 1(Event Player));
			While(Is Using Ability 1(Event Player));
				Event Player.invisible = True;
				Wait Until(!Is Using Ability 1(Event Player) || !Event Player.invisible, 9999);
			End;
		Else If(Hero Of(Event Player) == Hero(Doomfist) && Is Using Ultimate(Event Player));
			While(Is Using Ultimate(Event Player));
				Event Player.invisible = True;
				Wait Until(!Is Using Ultimate(Event Player) || !Event Player.invisible, 9999);
			End;
		Else If(Hero Of(Event Player) == Hero(Tracer) && Is Using Ability 2(Event Player));
			While(Is Using Ability 2(Event Player));
				Event Player.invisible = True;
				Wait Until(!Is Using Ability 2(Event Player) || !Event Player.invisible, 9999);
			End;
		End;
		Event Player.invisible = False;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("PLAYER AUTOMATIC RELOAD")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
		Ammo(Event Player, 0) == 0;
		Max Ammo(Event Player, 0) != 0;
	}

	actions
	{
		Wait(3, Abort When False);
		Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
		Small Message(Event Player, Custom String("Weapon reloaded"));
	}
}

rule("OBJECTIVE CHANGES AND PLAYER ENTITIES UPDATE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Has Spawned(Event Player) == True;
		(Event Player.objectiveValue != Global.objectiveValue || Count Of(Global.objectivePositions) == 1) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Call Subroutine(playerObjectiveEntityManagement);
	}
}

rule("PLAYER TARGET (ADD)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.afk != True;
		Has Spawned(Event Player) == True;
		Is Alive(Event Player) == True;
		Array Contains(Global.playerTargetList, Event Player) == False;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.032, Abort When False);
		Modify Global Variable(playerTargetList, Append To Array, Event Player);
		Loop If Condition Is True;
	}
}

rule("PLAYER TARGET (REMOVE)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		(Is Dead(Event Player) || !Has Spawned(Event Player)) == True;
		Array Contains(Global.playerTargetList, Event Player) == True;
		Is Dummy Bot(Event Player) == False;
	}

	actions
	{
		Wait(0.032, Abort When False);
		Modify Global Variable(playerTargetList, Remove From Array By Value, Event Player);
		Loop If Condition Is True;
	}
}

rule("playerObjectiveEntityMangement")
{
	event
	{
		Subroutine;
		playerObjectiveEntityManagement;
	}

	actions
	{
		If(Event Player.objectiveValue != Global.objectiveValue || Count Of(Global.objectivePositions) == 1);
			Event Player.objectiveValue = First Of(Global.objectiveTypes);
			"Destroy all current objective effects and texts"
			For Player Variable(Event Player, entityCount, 0, Count Of(Event Player.generalPlayerBotEntities), 1);
				Destroy Icon(Event Player.generalPlayerBotEntities[Event Player.entityCount]);
				Wait(0.016, Ignore Condition);
			End;
			Event Player.generalPlayerBotEntities = Empty Array;
			If(Event Player.objectiveValue == 4);
				"Player carrying resources icon"
				Create Icon(Filtered Array(All Players(Team 2), Is Alive(Event Player)
					&& Current Array Element != Event Player && Event Player.playerObjectiveResourceValue >= Global.amountPerResource),
					Event Player, Recycle, Visible To and Position, Color(Green), True);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			End;
		End;
	}
}

rule("needReviveTextLines")
{
	event
	{
		Subroutine;
		needReviveTextLines;
	}

	actions
	{
		Event Player.randVal = Random Integer(1, 100);
		If(Event Player.randVal <= 99);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"{2}\"", Event Player, Hero Icon String(Hero Of(Event Player)),
				Random Value In Array(Array(Custom String("I am seriously injured!"), Custom String("I need to be revived!"), Custom String(
				"I need medical assistance!"), Custom String("Someone get me a medic!"), Custom String("I need some help over here!"),
				Custom String("Someone help me up!")))));
		Else If(Event Player.randVal <= 100);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys I tripped and twisted my ankle.\"", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys it really hurts.\"", Event Player, Hero Icon String(Hero Of(
				Event Player))));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys...\"", Event Player, Hero Icon String(Hero Of(
				Event Player))));
			Wait(0.500, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Guys!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"", Event Player,
				Hero Icon String(Hero Of(Event Player))));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"OW OW OW OW OW OWWWWW!!!!\"", Event Player, Hero Icon String(
				Hero Of(Event Player))));
		End;
	}
}

rule("updateUsers")
{
	event
	{
		Subroutine;
		updateUsers;
	}

	actions
	{
		If(!Array Contains(Global.users, Custom String("{0}", Event Player)));
			"Add event player to users list"
			Modify Global Variable(users, Append To Array, Custom String("{0}", Event Player));
			"Index of user in user array"
			Event Player.userIndex = Index Of Array Value(Global.users, Custom String("{0}", Event Player));
			"0) Downed/Dead status, 1) Death timer, 2) Revive timer, 3) Revive start time, 4) Downed position"
			Global.globalPlayerStats[Event Player.userIndex] = Array(0, Event Player.deathTimer, Event Player.reviveTimer,
				Event Player.reviveStartTime, Position Of(Event Player));
		End;
	}
}

disabled rule("============================================== BOTS GAME IN PROGRESS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("BOT INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Global.specialGameModeSetup != True;
	}

	actions
	{
		Start Heal Over Time(Event Player, Null, 9999, 9999);
		Event Player.reviveTimer = 0;
		If(Count Of(Global.customTelePositions) > 0);
			Event Player.customTelePos = First Of(Global.customTelePositions);
			Modify Global Variable(customTelePositions, Remove From Array By Index, 0);
		Else;
			Event Player.customTelePos = Null;
		End;
		Event Player.canTeleport = False;
		"Damage over time duration"
		Chase Player Variable At Rate(Event Player, damageOverTimeDuration, -1, 0.950, None);
		"Bot target warning icon (flashing)"
		Create Icon(Filtered Array(Event Player.botTarget, !Event Player.botTarget.blinded && !Is In View Angle(Current Array Element,
			Position Of(Event Player), 55)), Event Player, Warning, Visible To Position and Color, Round To Integer(Total Time Elapsed * (
			Distance Between(Position Of(Event Player), Position Of(Local Player)) > 10 ? 4 : 8), Up) % 2 == 0 ? Color(Red) : Color(
			Yellow), True);
		Wait Until(Has Spawned(Event Player), 2);
		Set Max Health(Event Player, 1);
		Event Player.initialMaxHealth = Max Health(Event Player);
		"Bot Health Pool"
		Add Health Pool To Player(Event Player, Health, Max(0, Event Player.health - Event Player.initialMaxHealth), True, True);
		"Bot Health Pool"
		Add Health Pool To Player(Event Player, Health, Max(0, Event Player.health - 10000), True, True);
		Start Facing(Event Player, Throttle Of(Event Player), 100, To Player, Direction and Turn Rate);
		Set Respawn Max Time(Event Player, 30);
		If(!Array Contains(Global.bosses, Event Player));
			Call Subroutine(botRespawnInitialization);
		End;
		Event Player.canTeleport = True;
		"TESTING ONLY"
		disabled Create Icon(Filtered Array(All Players(All Teams), Array Contains(Global.botSpawnPoints, Event Player.telePos)),
			Event Player.telePos, Spiral, Visible To and Position, Color(Green), True);
		"TESTING ONLY"
		disabled Create In-World Text(All Players(All Teams), Custom String("Current Health:{0}, Recorded Max Health:{1}", Health(Event Player),
			Event Player.health), Event Player, 2, Do Not Clip, Visible To Position and String, Color(Green), Default Visibility);

			Wait Until(Event Player.botTarget != Null, 5);
		"Initial Outline Control"
		If(Event Player.defaultOutlineColor == Null);
			Stop Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 2), !Current Array Element.blinded));
		Else;
			"Mutation outline for non-blinded players"
			Start Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 2), !Current Array Element.blinded), True,
				Event Player.defaultOutlineColor, Default);
		End;
		"Disable outline for blinded players"
		Start Forcing Player Outlines(Event Player, Filtered Array(All Players(Team 2), Current Array Element.blinded), False, Color(
			White), Default);
	}
}

rule("KILL BOTS THAT ARE STUCK OR ARE NOT MOVING")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.teleporting != True;
		Event Player.specialThrottling != True;
		Event Player.attached != True;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		(Throttle Of(Event Player) == Vector(0, 0, 0) || Horizontal Speed Of(Event Player)
			< 1 * Event Player.botThrottleSpeed * Event Player.movementSpeed) == True;
		Is True For All(Global.playerTargetList, Distance Between(Position Of(Event Player), Position Of(Current Array Element))
			> 2.100 * Event Player.size) == True;
	}

	actions
	{
		If(Event Player.botTarget != Null);
			Wait(Random Real(7.500, 12.500), Abort When False);
		Else;
			Wait(5, Abort When False);
		End;
		Teleport(Event Player, Vector(0, -500, 0));
		Loop If Condition Is True;
	}
}

rule("BOT DIES")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Dead(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Event Player.botTarget = Null;
		Event Player.potentialTargets = Empty Array;
		Stop All Damage Over Time(Event Player);
		Stop Throttle In Direction(Event Player);
		Stop Facing(Event Player);
		If(!Event Was Environment || Team Of(Attacker) == Team 2);
			Disable Nameplates(Event Player, All Players(All Teams));
			"Allow for custom revive times"
			Wait Until(Event Player.reviveTimer != 0, 0.125);
			If(Event Player.reviveTimer == 0);
				Event Player.reviveTimer = (Match Time + Global.matchEndTime) / 240;
			End;
			If(Count Of(Global.spawnTimes) < Global.numberOfBots);
				Modify Global Variable(spawnTimes, Append To Array, Event Player.reviveTimer);
			End;
			If(Event Player.customTelePos);
				Modify Global Variable(customTelePositions, Append To Array, Event Player.customTelePos);
			End;
			Wait(1, Ignore Condition);
			Wait Until(Event Player.damageOverTimeDuration <= 0, 10);
			Call Subroutine(updateBotSpawnPoints);
			Destroy Dummy Bot(Team 1, Slot Of(Event Player));
			Abort;
		Else If(Event Was Environment && Distance Between(Position Of(Event Player), Vector(X Component Of(Event Player.telePos),
				Y Component Of(Position Of(Event Player)), Z Component Of(Event Player.telePos))) < 10);
			Event Player.successfullyTeleported = False;
		End;
		Event Player.teleporting = True;
		Teleport(Event Player, Vector(500, 50, 500));
		Wait(0.250, Ignore Condition);
		Resurrect(Event Player);
	}
}

rule("TELEPORT BOTS (GENERAL)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		Number Of Living Players(Team 2) > 0;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Call Subroutine(teleportBots);
	}
}

rule("TELEPORT BOTS WHEN NOT USED FOR TOO LONG")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.teleporting != True;
		Global.gameStatus == True;
		Event Player.attached != True;
		Event Player.targeting != True;
		Event Player.botTarget == Null;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		Is True For All(Filtered Array(Global.playerTargetList, Current Array Element.invisible), !Is In Line of Sight(Eye Position(
			Current Array Element), Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		If(Event Player.successfullyTeleported);
			Wait(10, Abort When False);
		Else;
			Wait(0.500, Abort When False);
			Wait(Max(1, 7 - Distance Between(Position Of(Event Player), Event Player.averagePlayersPos) / 8), Abort When False);
			Loop If(Event Player.successfullyTeleported);
		End;
		Call Subroutine(teleportBots);
		Loop;
	}
}

rule("BOT STUN MANAGEMENT")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Has Status(Event Player, Knocked Down) || Has Status(Event Player, Asleep) || Has Status(Event Player, Frozen) || Has Status(
			Event Player, Stunned)) == True;
	}

	actions
	{
		Event Player.crowdControlled = True;
		Wait(0.125, Ignore Condition);
		Loop If Condition Is True;
		Event Player.crowdControlled = False;
	}
}

rule("UPDATE SUCCESSFUL TELEPORT STATUS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.teleporting != True;
		Event Player.successfullyTeleported != True;
		Global.specialGameModeSetup != True;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		If(!Event Player.successfullyTeleported);
			Event Player.successfullyTeleported = True;
		End;
		If(Distance Between(Event Player.telePos, Event Player.averagePlayersPos) < Global.botMaxTeleportRange[1]);
			Event Player.waypoint = Position Of(Event Player);
			Call Subroutine(updateBotSpawnPoints);
		End;
	}
}

rule("BOT TARGET VISIBLE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		Event Player.teleporting != True;
		Event Player.initializing != True;
		Is Alive(Event Player) == True;
		Has Spawned(Event Player) == True;
		(Event Player.botTarget == Null || Is True For Any(Remove From Array(Global.playerTargetList, Event Player.botTarget),
			!Current Array Element.invisible && Distance Between(Position Of(Current Array Element), Position Of(Event Player)) < 7.500))
			== True;
		Is True For Any(Global.playerTargetList, !Current Array Element.invisible && Distance Between(Position Of(Event Player),
			Position Of(Current Array Element)) < 150 && Is In Line of Sight(Eye Position(Current Array Element), Position Of(Event Player)
			+ Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Wait(0.016, Abort When False);
		Start Rule(selectTarget, Restart Rule);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("selectTarget")
{
	event
	{
		Subroutine;
		selectTarget;
	}

	actions
	{
		Event Player.targeting = True;
		"Set potential targets empty"
		Event Player.potentialTargets = Empty Array;
		"Prioitize dummy bots"
		Modify Player Variable(Event Player, potentialTargets, Append To Array, Filtered Array(Global.playerTargetList, Is Dummy Bot(
			Current Array Element)));
		"Add players who are below bot to target list"
		Modify Player Variable(Event Player, potentialTargets, Append To Array, Sorted Array(Filtered Array(Remove From Array(
			Global.playerTargetList, Event Player.potentialTargets), Y Component Of(Position Of(Current Array Element)) - Y Component Of(
			Position Of(Event Player)) < 2.500), Distance Between(Position Of(Event Player), Position Of(Current Array Element))));
		"Add remaining players"
		Modify Player Variable(Event Player, potentialTargets, Append To Array, Sorted Array(Remove From Array(Global.playerTargetList,
			Event Player.potentialTargets), Distance Between(Position Of(Event Player), Position Of(Current Array Element))));
		"Remove invisible players"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, !Current Array Element.invisible);
		For Player Variable(Event Player, pPowerUpCount_bTeleCount, 0, Count Of(Event Player.potentialTargets), 1);
			Event Player.testTarget = Event Player.potentialTargets[Event Player.pPowerUpCount_bTeleCount];
			If(Is In Line of Sight(Eye Position(Event Player.testTarget), Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0),
				Barriers Do Not Block LOS));
				Break;
			End;
			disabled Wait(0.016, Ignore Condition);
		End;
		If(Is Alive(Event Player));
			Event Player.botTarget = Event Player.testTarget;
			Event Player.lastTarget = Event Player.botTarget;
			Start Rule(restoreDefaultFacingMovement, Restart Rule);
		End;
		Event Player.targeting = False;
	}
}

rule("restoreDefaultFacingMovement")
{
	event
	{
		Subroutine;
		restoreDefaultFacingMovement;
	}

	actions
	{
		If(Event Player.botTarget != Null);
			If(!Event Player.specialFacing);
				Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botTarget)),
					Event Player.attached ? 1500 : (Event Player.crowdControlled ? 0 : 100), To World, Direction and Turn Rate);
			End;
			If(!Event Player.specialThrottling);
				Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget)),
					Distance Between(Position Of(Event Player), Vector(X Component Of(Position Of(Event Player.botTarget)), Y Component Of(
					Position Of(Event Player)), Z Component Of(Position Of(Event Player.botTarget)))) > 2 * Min(1, Event Player.size)
					? Event Player.botThrottleSpeed : 0, To World, Replace existing throttle, Direction and Magnitude);
			End;
		Else;
			Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
				Replace existing throttle, None);
			Start Facing(Event Player, Throttle Of(Event Player), 100, To Player, Direction and Turn Rate);
		End;
	}
}

rule("DESELECT BOT TARGET")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.teleporting != True;
		Event Player.botTarget != Null;
		(Event Player.botTarget.invisible || !Array Contains(Global.playerTargetList, Event Player.botTarget) || !Is In Line of Sight(
			Eye Position(Event Player.botTarget), Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0),
			Barriers Do Not Block LOS)) == True;
	}

	actions
	{
		Event Player.botTarget = Null;
		If(!Event Player.specialThrottling);
			Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.lastTarget)
				+ Normalize(World Vector Of(Throttle Of(Event Player.lastTarget), Event Player.lastTarget, Rotation)) * -2),
				Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
		End;
		If(!Event Player.specialFacing);
			Start Facing(Event Player, Throttle Of(Event Player), Event Player.crowdControlled ? 0 : 100, To Player, Direction and Turn Rate);
		End;
		Wait(0.125, Restart When True);
		Loop If Condition Is True;
	}
}

rule("BOT WANDERS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.botTarget == Null;
		Event Player.specialThrottling != True;
		Event Player.specialFacing != True;
		Event Player.crowdControlled != True;
		Has Status(Event Player, Rooted) == False;
		"Allows if bot bumps into something"
		Horizontal Speed Of(Event Player) < Event Player.botThrottleSpeed * Event Player.movementSpeed * 3.500;
		Global.specialGameModeSetup != True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Start Throttle In Direction(Event Player, Direction From Angles(Horizontal Angle From Direction(World Vector Of(Throttle Of(
			Event Player), Event Player, Rotation)) + Random Real(90, 270), 0), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, None);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BOTS JUMP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.specialGameModeSetup != True;
		Event Player.specialThrottling == False;
		Event Player.attached != True;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Is Jumping(Event Player) != True;
		Is On Ground(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		Is Crouching(Event Player) == False;
		(Event Player.botTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 2) == True;
		"Allows if bot bumps into something"
		Horizontal Speed Of(Event Player) < Event Player.botThrottleSpeed * Event Player.movementSpeed * 3.500;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Jump));
		Loop If Condition Is True;
	}
}

rule("BOTS MOVE THROUGH SPAWN DOORS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.wallCollisionEnabled == True;
		Event Player.canWallPhase == True;
		Event Player.attached != True;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Has Status(Event Player, Rooted) == False;
		Throttle Of(Event Player) != Vector(0, 0, 0);
		(Is On Ground(Event Player) || (Array Contains(Global.bosses, Event Player) && Altitude Of(Event Player) < 10)) == True;
		"Allows if bot bumps into something"
		Speed Of In Direction(Event Player, World Vector Of(Throttle Of(Event Player), Event Player, Rotation))
			< Event Player.botThrottleSpeed * Event Player.movementSpeed * 3;
		"Makes sure bot is moving forward"
		Speed Of In Direction(Event Player, World Vector Of(Throttle Of(Event Player), Event Player, Rotation)) >= 0;
		Is In Line of Sight(Position Of(Event Player) + Vector(0, 0.750, 0) * Event Player.size, Position Of(Event Player) + Vector(0,
			0.750, 0) * Event Player.size + Normalize(World Vector Of(Throttle Of(Event Player), Event Player, Rotation))
			* 3 * Event Player.size, Barriers Do Not Block LOS) == True;
	}

	actions
	{
		Wait(0.125, Abort When False);
		Disable Movement Collision With Environment(Event Player, False);
		Event Player.wallCollisionEnabled = False;
		If(Array Contains(Global.bosses, Event Player));
			Wait(2, Restart When True);
		Else;
			Wait(1, Ignore Condition);
		End;
		Loop If Condition Is True;
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		If(!Array Contains(Global.bosses, Event Player));
			Wait(5, Ignore Condition);
		End;
	}
}

rule("BOTS MELEE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Meleeing(Event Player) != True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 3 * Event Player.size;
		Horizontal Speed Of(Event Player.botTarget) < 15 * Event Player.botTarget.movementSpeed;
	}

	actions
	{
		Wait(0.125, Abort When False);
		Press Button(Event Player, Button(Melee));
		Loop If Condition Is True;
	}
}

rule("BOTS INFLICT DAMAGE OVER TIME (INFECTION LEVEL MANAGEMENT)")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Ability == Button(Melee);
		Team Of(Victim) == Team 2;
	}

	actions
	{
		Start Damage Over Time(Victim, Event Player, Event Player.biteDuration, Event Player.biteDamage);
		If(Event Player.damageOverTimeDuration < Event Player.biteDuration);
			Event Player.damageOverTimeDuration = Event Player.biteDuration;
		End;
		If(Workshop Setting Toggle(Custom String("Infection"), Custom String("Melee Infection Enabled"), False, 0) && !Has Status(
			Event Player, Hacked) && !Is Dummy Bot(Victim) && Health(Victim) <= Victim.initialMaxHealth);
			If(Victim.infected);
				Victim.infectionLvl += 1 / Workshop Setting Integer(Custom String("Infection"), Custom String("Hits to increase infection level"),
					2, 1, 20, 2);
			Else;
				Victim.infectionLvl += 1 / Workshop Setting Integer(Custom String("Infection"), Custom String("Hits to get infected"), 4, 1, 20,
					1);
			End;
			If(!Victim.infected && Victim.infectionLvl >= 1);
				Victim.infected = True;
			End;
	}
}

rule("BOTS RECOIL FROM DAMAGE")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Damage > 20;
		Event Player.crowdControlled != True;
		Event Player.attached != True;
		Team Of(Attacker) == Team 2;
		Is Alive(Victim) == True;
		disabled Event Damage * 1.100 / Victim.health > 0.350;
		Event Damage > 0.300 * Event Player.health;
	}

	actions
	{
		If(Is In Air(Victim) && Event Was Critical Hit);
			Set Status(Victim, Attacker, Knocked Down, 3);
		Else;
			Set Status(Victim, Attacker, Stunned, 0.500);
		End;
		Apply Impulse(Victim, Direction From Angles(Random Real(-20, 20) + Horizontal Angle From Direction(Event Direction), 0),
			Event Damage * 15 / Victim.health * Event Player.knockbackRecieved, To World, Incorporate Contrary Motion);
	}
}

rule("enterExitTeleport")
{
	event
	{
		Subroutine;
		enterExitTeleport;
	}

	actions
	{
		If(Event Player.teleporting);
			Set Invisible(Event Player, All);
			Stop Throttle In Direction(Event Player);
			Set Gravity(Event Player, 0);
		Else;
			Set Status(Event Player, Null, Rooted, 0.250);
			Set Invisible(Event Player, None);
			Set Gravity(Event Player, 100);
			If(Event Player.botTarget == Null);
				If(Array Contains(Global.botSpawnPoints, Event Player.telePos));
					Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Global.waypoints[Index Of Array Value(
						Global.botSpawnPoints, Event Player.telePos)]), Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
				Else;
					Start Throttle In Direction(Event Player, Direction From Angles(Random Integer(-90, 90) + Horizontal Angle From Direction(
						Direction Towards(Position Of(Event Player), Position Of(First Of(Sorted Array(Filtered Array(All Living Players(Team 2),
						Has Spawned(Current Array Element)), Distance Between(Position Of(Event Player), Position Of(Current Array Element))))))), 0),
						Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
				End;
			Else If(Event Player.botTarget != Null);
				Start Rule(restoreDefaultFacingMovement, Do Nothing);
			End;
		End;
	}
}

rule("teleportBots")
{
	event
	{
		Subroutine;
		teleportBots;
	}

	actions
	{
		Event Player.teleporting = True;
		Call Subroutine(updateBotSpawnPoints);
		Call Subroutine(enterExitTeleport);
		Event Player.successfullyTeleported = False;
		Wait Until(!Event Player.initializing && Event Player.canTeleport, 99999);
		If(Event Player.customTelePos == Null);
			While(Event Player.teleporting);
				Call Subroutine(botTeleportCenter);
				Wait(0.016, Ignore Condition);
				Event Player.telePos = 0;
				"Teleport with max distance constraint no view angle constraint"
				While(Event Player.telePos == 0 || Is True For Any(Global.playerTargetList, Distance Between(Event Player.telePos, Position Of(
					Current Array Element)) < 15) || Is True For All(Global.playerTargetList, Distance Between(Event Player.telePos, Position Of(
					Current Array Element)) > Global.botMaxTeleportRange[1]));
					Event Player.filteredBotSpawnPointGrid = Filtered Array(Global.botSpawnPoints, Distance Between(Current Array Element,
						Event Player.averagePlayersPos) < Global.botMaxTeleportRange[1]);
					"Filter out spawn points on cooldown"
					Event Player.filteredBotSpawnPointGrid = Filtered Array(Event Player.filteredBotSpawnPointGrid,
						Global.botSpawnPointTimers[Index Of Array Value(Global.botSpawnPoints, Current Array Element)] < 15);
					"Bots utilize saved spawn points"
					If(Count Of(Global.botSpawnPoints) > 0 && Count Of(Event Player.filteredBotSpawnPointGrid) > 0);
						Event Player.telePos = Random Value In Array(Event Player.filteredBotSpawnPointGrid);
						Global.botSpawnPointTimers[Index Of Array Value(Global.botSpawnPoints, Event Player.telePos)] += 5;
						Break;
					Else;
						Event Player.telePos = Nearest Walkable Position(Event Player.averagePlayersPos + Direction From Angles(Random Real(0, 360),
							Random Real(-20, 10)) * Random Real(0, Global.botMaxTeleportRange[1]));
					End;
					Wait(0.250, Ignore Condition);
				End;
				If(Is True For All(Global.playerTargetList, Distance Between(Event Player.telePos, Position Of(Current Array Element)) > 10)
					&& Is True For All(Filtered Array(Global.playerTargetList, Is In View Angle(Current Array Element, Event Player.telePos, 55)),
					!Is In Line of Sight(Eye Position(Current Array Element), Event Player.telePos + Vector(0, Global.losHeightCheck, 0),
					Barriers Do Not Block LOS)));
					Teleport(Event Player, Event Player.telePos);
					Event Player.teleporting = False;
				"Teleport was unsuccessful due to line of sight and view angle"
				Else If(Array Contains(Global.botSpawnPoints, Event Player.telePos));
					Modify Global Variable(waypoints, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints, Event Player.telePos));
					Modify Global Variable(botSpawnPointTimers, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints,
						Event Player.telePos));
					Modify Global Variable(botSpawnPoints, Remove From Array By Value, Event Player.telePos);
				End;
			End;
		Else;
			Teleport(Event Player, Event Player.customTelePos);
			Event Player.customTelePos = Null;
			Event Player.teleporting = False;
		End;
		Wait(0.016, Ignore Condition);
		Call Subroutine(enterExitTeleport);
	}
}

rule("botTeleportCenter")
{
	event
	{
		Subroutine;
		botTeleportCenter;
	}

	actions
	{
		"Capture Point/Extration Point"
		If(True);
			Event Player.averagePlayersPos = Payload Position + Direction Towards(Payload Position, Objective Position(Objective Index)) * Min(20, Distance Between(Payload Position, Objective Position(Objective Index)));
		Else;
			Call Subroutine(locateAveragePlayerLocation);
		End;
	}
}

rule("locateAveragePlayerLocation")
{
	event
	{
		Subroutine;
		locateAveragePlayerLocation;
	}

	actions
	{
		Event Player.averagePlayersPos = Vector(0, 0, 0);
		If(Count Of(Global.playersOnObjective) == 0 && Is True For Any(Global.playerTargetList, Throttle Of(Current Array Element)
			!= Vector(0, 0, 0)));
			For Player Variable(Event Player, pPowerUpCount_bTeleCount, 0, Count Of(Filtered Array(Global.playerTargetList, Throttle Of(
				Current Array Element) != Vector(0, 0, 0))), 1);
				Event Player.averagePlayersPos += Position Of(Filtered Array(Global.playerTargetList, Throttle Of(Current Array Element) != Vector(
					0, 0, 0))[Event Player.pPowerUpCount_bTeleCount]);
			End;
		Else;
			For Player Variable(Event Player, pPowerUpCount_bTeleCount, 0, Count Of(Global.playerTargetList), 1);
				Event Player.averagePlayersPos += Position Of(Global.playerTargetList[Event Player.pPowerUpCount_bTeleCount]);
			End;
		End;
		Event Player.averagePlayersPos /= Event Player.pPowerUpCount_bTeleCount;
	}
}

rule("successfulTeleportStatus")
{
	event
	{
		Subroutine;
		successfulTeleportStatus;
	}

	actions
	{
		"Max teleport distance adjustment"
		If(!Event Player.successfullyTeleported);
			Event Player.successfullyTeleported = True;
		End;
	}
}

rule("updateBotSpawnPoints")
{
	event
	{
		Subroutine;
		updateBotSpawnPoints;
	}

	actions
	{
		If(Event Player.successfullyTeleported && Event Player.customTelePos == Null && !Array Contains(Global.botSpawnPoints,
			Event Player.telePos));
			Modify Global Variable(botSpawnPoints, Append To Array, Event Player.telePos);
			Modify Global Variable(waypoints, Append To Array, Event Player.waypoint);
			Modify Global Variable(botSpawnPointTimers, Append To Array, 0);
		Else If(!Event Player.successfullyTeleported && Array Contains(Global.botSpawnPoints, Event Player.telePos));
			Modify Global Variable(waypoints, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints, Event Player.telePos));
			Modify Global Variable(botSpawnPointTimers, Remove From Array By Index, Index Of Array Value(Global.botSpawnPoints,
				Event Player.telePos));
			Modify Global Variable(botSpawnPoints, Remove From Array By Value, Event Player.telePos);
		End;
	}
}

rule("botRespawnInitialization")
{
	event
	{
		Subroutine;
		botRespawnInitialization;
	}

	actions
	{
		Event Player.initializing = True;
		If(Array Contains(Global.bosses, Event Player));
			Disable Nameplates(Event Player, All Players(All Teams));
			Event Player.health = 0;
			Event Player.initialMaxHealth = Max Health(Event Player);
		Else;
			Enable Nameplates(Event Player, All Players(All Teams));
			Event Player.size = Workshop Setting Real(Custom String("Zombies"), Custom String("Zombie Size"), 1, 0, 20, 0);
			Event Player.health = Global.botHealthValues[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
			"Scale zombie voice lines with size"
			Start Modifying Hero Voice Lines(Event Player, 0.500 + 1 / (Event Player.size + 1) + 0.250 * Sine From Degrees(
				Total Time Elapsed * Evaluate Once(Random Real(360, 720))), True);
		End;
		Stop Holding Button(Event Player, Button(Crouch));
		Stop Holding Button(Event Player, Button(Primary Fire));
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		Enable Movement Collision With Players(Event Player);
		Event Player.playerCollisionEnabled = True;
		Event Player.canWallPhase = True;
		Event Player.attached = False;
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Event Player.canWallPhase = True;
		Event Player.crowdControlled = False;
		Event Player.botTempValue = Null;
		Event Player.botSpecialTarget = Null;
		Event Player.targeting = False;
		Event Player.bossHealth = -1;
		Call Subroutine(botStatManagement);
		Call Subroutine(mutations);
		Start Scaling Player(Event Player, Event Player.size, False);
		Call Subroutine(botEntityManagement);
		Wait Until(Health(Event Player) >= Event Player.health, 5);
		Stop All Heal Over Time(Event Player);
		Set Player Health(Event Player, Event Player.health);
		Event Player.initializing = False;
	}
}

rule("botEntityManagement")
{
	event
	{
		Subroutine;
		botEntityManagement;
	}

	actions
	{
		If(Event Player.botHero != Hero Of(Event Player) || Array Contains(Global.bosses, Event Player));
			Event Player.botHero = Hero Of(Event Player);
			"Destroy all current hero effects and texts"
			For Player Variable(Event Player, entityCount, 0, Count Of(Event Player.generalPlayerBotEntities), 1);
				Destroy Effect(Event Player.generalPlayerBotEntities[Event Player.entityCount]);
				Wait(0.016, Ignore Condition);
			End;
			Event Player.generalPlayerBotEntities = Empty Array;
			If(Hero Of(Event Player) == Hero(Roadhog));
				If(Array Contains(Global.bosses, Event Player));
					"Gas Projectile 1"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.chase1 != Null), Bad Aura, Color(Lime Green),
						Event Player.chase1, 0.400 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Gas Projectile 2"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.chase1 != Null), Good Aura, Color(Lime Green),
						Event Player.chase1, 0.200 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Gas Clouds"
					For Player Variable(Event Player, entityCount, 0, 3, 1);
						"Cloud Effect"
						Create Effect(Filtered Array(All Players(All Teams), Event Player.abilityArray1[Evaluate Once(Event Player.entityCount)] != Null),
							Cloud, Color(Lime Green), Event Player.abilityArray1[Evaluate Once(Event Player.entityCount)],
							Event Player.abilityArray2[Evaluate Once(Event Player.entityCount)] + 2, Visible To Position and Radius);
						Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					End;
				Else;
					"Roadhog toxic cloud"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ability 2(Event Player)), Cloud, Color(Lime Green), Event Player,
						10 * Event Player.size + 2.500, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Mercy));
				"Mercy tentacle"
				Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue != 0), Bad Beam, Is In Air(Event Player)
					? Eye Position(Event Player) + Vector(0, 0.500, 0) * Event Player.size : Eye Position(Event Player), Event Player.chase1,
					Color(Lime Green), Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Tentacle sound effect"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue != 0), Energy Sound, Color(White),
					Event Player.chase1, 400, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Tentacle end visual effect"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue != 0), Good Aura, Color(Lime Green),
					Event Player.chase1, 0.100, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Boss only"
				If(Array Contains(Global.bosses, Event Player));
					"Ultimate lift aura"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ultimate(Event Player) && Is In View Angle(Current Array Element,
						Position Of(Event Player), 60)), Good Aura, Color(Yellow), Position Of(Event Player), 12 * Event Player.size,
						Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Wrecking Ball));
				"Ground strike location"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue), Ring, Color(Team 1),
					Event Player.botTempValue ? Ray Cast Hit Position(Position Of(Event Player), Position Of(Event Player) + Vector(0, -100, 0),
					All Players(All Teams), All Players(All Teams), False) : Evaluate Once(Vector(0, -100, 0)), 1 * Event Player.size,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			Else If(Hero Of(Event Player) == Hero(Junkrat));
				"Boss Only"
				If(Array Contains(Global.bosses, Event Player));
					"Pre-explosion sound"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue), Energy Sound, Color(White), Eye Position(
						Local Player) + Direction Towards(Eye Position(Local Player), Position Of(Event Player)), 200, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Pre-explosion visual"
					Create Effect(Filtered Array(All Players(All Teams), Event Player.botTempValue), Bad Aura, Color(Orange), Event Player,
						1.500 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Reaper));
				"Boss Only"
				If(Array Contains(Global.bosses, Event Player));
					"Using Wraith Form"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ability 1(Event Player) && Is In View Angle(Current Array Element,
						Position Of(Event Player), 60)), Bad Aura, Color(Gray), Position Of(Event Player), 12 * Event Player.size,
						Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
					"Using Wraith Form"
					Create Effect(Filtered Array(All Players(All Teams), Is Using Ability 1(Event Player)), Cloud, Color(White), Event Player,
						12 * Event Player.size, Visible To Position and Radius);
					Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				End;
			Else If(Hero Of(Event Player) == Hero(Pharah));
				"Charging attack effect"
				Create Effect(Filtered Array(All Players(All Teams), Event Player.chase1 > 0), Good Aura, Color(Blue), Event Player,
					Event Player.chase1 * Event Player.size, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			Else If(Hero Of(Event Player) == Hero(Ramattra));
				"Nemesis will activate aura"
				Create Effect(Filtered Array(Global.playerTargetList, !Event Player.botTempValue && Is Alive(Event Player)
					&& Event Player.botTarget && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 12 *
					Event Player.size), Bad Aura, Color(Purple), Event Player, 1 * Event Player.size, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Angered area of effect"
				Create Effect(Filtered Array(Global.playerTargetList, Event Player.botTempValue), Ring, Color(Red), Event Player, 12 * Event Player.size, Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			Else If(Hero Of(Event Player) == Hero(Sombra));
				"Near fog visual"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True), Bad Aura, Color(Gray),
					Eye Position(Local Player) + Facing Direction Of(Local Player) * (6.750 + Evaluate Once(Random Real(-0.500, 0.500))), 200,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Mid Range fog visual"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True), Bad Aura, Color(Purple),
					Eye Position(Local Player) + Facing Direction Of(Local Player) * (20 + Evaluate Once(Random Real(-0.500, 0.500))), 200,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Mid Range fog visual"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True), Bad Aura, Color(Purple),
					Eye Position(Local Player) + Facing Direction Of(Local Player) * (30 + Evaluate Once(Random Real(-0.500, 0.500))), 200,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
				"Illusion aura"
				Create Effect(Filtered Array(Event Player.botSpecialPotentialTargets, True && Is Using Ability 1(
					Event Player)), Good Aura, Color(Purple), Eye Position(Event Player), 0.250 * Event Player.size,
					Visible To Position and Radius);
				Modify Player Variable(Event Player, generalPlayerBotEntities, Append To Array, Last Created Entity);
			End;
		End;
	}
}

rule("botStatManagement")
{
	event
	{
		Subroutine;
		botStatManagement;
	}

	actions
	{
		Event Player.biteDamage = Global.biteDamages[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		"Re-calibrate bite damage"
		Event Player.biteDamage *= 100 / Global.damageDealt[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		Event Player.biteDuration = Global.biteDurations[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		"Range from 0 to 1 in terms of throttle"
		Event Player.botThrottleSpeed = Global.throttleSpeeds[Index Of Array Value(Global.botHeros, Hero Of(Event Player))];
		Event Player.damageDealt = Global.damageDealt[Index Of Array Value(Global.botHeros, Hero Of(Event Player))] / 100;
		Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		Set Damage Received(Event Player, 100);
		Event Player.movementSpeed = 1;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Set Jump Vertical Speed(Event Player, 100);
		Set Projectile Speed(Event Player, 100);
		Set Projectile Gravity(Event Player, 100);
		Set Healing Dealt(Event Player, 100);
		Event Player.knockbackRecieved = 1;
		Set Knockback Received(Event Player, 100);
		If(Hero Of(Event Player) == Hero(Reinhardt));
			Event Player.knockbackRecieved = 0.700;
			Set Knockback Received(Event Player, 100 * Event Player.knockbackRecieved);
		Else If(Hero Of(Event Player) == Hero(Genji));
			Set Projectile Speed(Event Player, 20);
		Else If(Hero Of(Event Player) == Hero(Reaper));
			Set Healing Dealt(Event Player, 0);
		Else If(Hero Of(Event Player) == Hero(Mercy));
			Set Projectile Speed(Event Player, 20);
		Else If(Hero Of(Event Player) == Hero(Junkrat));
			If(Array Contains(Global.bosses, Event Player));
				Event Player.movementSpeed = 1.500;
				Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			End;
		End;
	}
}

rule("enableMutations")
{
	event
	{
		Subroutine;
		enableMutations;
	}

	actions
	{
		Global.availableMutations[0] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Speed"), True, 0) ? 1 : -1;
		Global.availableMutations[1] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Size Growth"), True, 1) ? 2 : -1;
		Global.availableMutations[2] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Size Reduction"), True, 2)
			? 3 : -1;
		Global.availableMutations[3] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Radioactive"), True, 3) ? 4 : -1;
		Global.availableMutations[4] = Workshop Setting Toggle(Custom String("Mutations"), Custom String("Heavy"), True, 4) ? 5 : -1;
		Modify Global Variable(availableMutations, Remove From Array By Value, -1);
	}
}

rule("mutations")
{
	event
	{
		Subroutine;
		mutations;
	}

	actions
	{
		"Zombies have a chance to mutate. Bosses cannot mutate"
		If(Count Of(Global.availablePowerups) > 0 && !Array Contains(Global.bosses, Event Player) && Random Real(0, 100)
			< Workshop Setting Real(Custom String("Mutations"), Custom String("Chance to mutate percentage"), 25, 0, 100, -1));
			Event Player.mutationValue = Random Value In Array(Global.availableMutations);
			"Speed"
			If(Event Player.mutationValue == 1);
				Event Player.movementSpeed *= Workshop Setting Real(Custom String("Mutations"), Custom String("Speed Scalar"), 1.500, 0, 10, 0);
				Set Move Speed(Event Player, Event Player.movementSpeed * 100);
				Event Player.defaultOutlineColor = Color(Purple);
				Start Forcing Dummy Bot Name(Event Player, Custom String("SPEED"));
			"Size Growth"
			Else If(Event Player.mutationValue == 2);
				Event Player.size *= Workshop Setting Real(Custom String("Mutations"), Custom String("Size Growth Scalar"), 1.500, 1, 20, 1);
				Event Player.health *= Event Player.size;
				Event Player.defaultOutlineColor = Color(Violet);
				Start Forcing Dummy Bot Name(Event Player, Custom String("XL"));
			"Size Reduction"
			Else If(Event Player.mutationValue == 3);
				Event Player.size *= Workshop Setting Real(Custom String("Mutations"), Custom String("Size Reduction Scalar"), 0.600, 0.100, 1, 2);
				Event Player.health *= Event Player.size;
				Event Player.defaultOutlineColor = Color(Rose);
				Start Forcing Dummy Bot Name(Event Player, Custom String("XS"));
			"Radioactive"
			Else If(Event Player.mutationValue == 4);
				Event Player.biteDuration *= Workshop Setting Real(Custom String("Mutations"), Custom String("Radioactivity Damage Scalar"), 2, 1,
					5, 3);
				Event Player.defaultOutlineColor = Color(Lime Green);
				Start Forcing Dummy Bot Name(Event Player, Custom String("Radioactive"));
			"Heavy"
			Else If(Event Player.mutationValue == 5);
				Event Player.knockbackRecieved *= Workshop Setting Real(Custom String("Mutations"), Custom String(
					"Heavy Knockback Reduction Scalar Scalar"), 0.500, 0.100, 1, 4);
				Set Knockback Received(Event Player, 100 * Event Player.knockbackRecieved);
				"Scale move speed"
				Event Player.movementSpeed *= Event Player.knockbackRecieved;
				Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
				"Scale health"
				Event Player.health /= Event Player.knockbackRecieved;
				Event Player.defaultOutlineColor = Color(Black);
				Start Forcing Dummy Bot Name(Event Player, Custom String("Heavy"));
			End;
		Else;
			Event Player.mutationValue = 0;
			Event Player.defaultOutlineColor = Null;
			Stop Forcing Dummy Bot Name(Event Player);
		End;
	}
}

disabled rule("============================================== ZOMBIE TYPES ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("BASIC (REAPER) SHADOW STEP (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reaper;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Array Contains(Global.bosses, Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, False);
		Press Button(Event Player, Button(Ability 2));
		Wait(1, Ignore Condition);
		While(!Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Primary Fire));
			Wait Until(Is Using Ability 2(Event Player), 0.500);
			If(Is Using Ability 2(Event Player));
				Wait Until(!Is Using Ability 2(Event Player), 2);
				Break;
			End;
			Press Button(Event Player, Button(Ability 2));
		End;
		Press Button(Event Player, Button(Ability 1));
		Wait(0.250, Ignore Condition);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Vector(-1, 0, 0), 180, To Player, Direction and Turn Rate);
		While(Is Using Ability 1(Event Player));
			Event Player.botSpecialPotentialTargets = Filtered Array(All Living Players(All Teams),
				Current Array Element != Event Player && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
				< 12 * Event Player.size && Is In Line of Sight(Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
				Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS));
			For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
				Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
				If(Y Component Of(Position Of(Event Player.botSpecialTarget)) < Y Component Of(Position Of(Event Player)) + 4 * Event Player.size);
					"Make target float up"
					Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
						Event Player.botSpecialTarget), Position Of(Event Player))), -50), 1, To World, Incorporate Contrary Motion);
				Else;
					"Push target straight up"
					Apply Impulse(Event Player.botSpecialTarget, Vector(0, 1, 0), 0.500, To World, Incorporate Contrary Motion);
				End;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Set Ability Cooldown(Event Player, Button(Ability 2), 5);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("BOMBER (JUNKRAT) SELF DESTRUCT")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Junkrat;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		"Scaled"
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) <= 2.750 * Event Player.size;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.botTempValue = True;
		"Pre-explosion sound"
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Orange), Event Player, 200);
		"Scaled"
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Event Player, 0.500 * Event Player.size);
		"Bosses only"
		If(Array Contains(Global.bosses, Event Player));
			Set Status(Event Player, Null, Rooted, 2.500);
			Set Status(Event Player, Null, Burning, 2.500);
			Set Status(Event Player, Null, Stunned, 2.500);
			Event Player.botSpecialTarget = First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(Event Player),
				Position Of(Current Array Element))));
			Small Message(Players Within Radius(Position Of(Event Player), 10 * Event Player.size, Team 2, Off), Custom String(
				"{0} {1}: \"{2}\"", Event Player.botSpecialTarget, Hero Icon String(Hero Of(Event Player.botSpecialTarget)),
				Random Value In Array(Array(Custom String("It's gonna blow! Get down!"), Custom String("Take cover!"), Custom String(
				"Everyone get down!"), Custom String("Get to cover!"), Custom String("Look out!")))));
			Wait(1.500, Ignore Condition);
			Event Player.botTempValue = False;
			Abort If(Is Dead(Event Player));
		Else;
			Set Status(Event Player, Null, Burning, 0.600);
			Set Status(Event Player, Null, Rooted, 0.600);
			Wait(0.500, Ignore Condition);
			Event Player.botTempValue = False;
			Abort If(Is Dead(Event Player));
			Kill(Event Player, Null);
		End;
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, 1, 1);
			Event Player.botSpecialPotentialTargets = Filtered Array(All Living Players(All Teams), Distance Between(Position Of(Event Player),
				Position Of(Current Array Element)) < Event Player.size * 6 && Is In Line of Sight(Eye Position(Current Array Element),
				Eye Position(Event Player), Enemy Barriers Block LOS));
			"Scaled"
			Damage(Filtered Array(Event Player.botSpecialPotentialTargets, Distance Between(Position Of(Event Player), Position Of(
				Current Array Element)) < 3 * Event Player.size), Event Player, Event Player.biteDamage * 5);
			"Scaled"
			Damage(Event Player.botSpecialPotentialTargets, Event Player, Event Player.biteDamage * 2.500);
			"Scaled"
			Set Status(Event Player.botSpecialPotentialTargets, Event Player, Burning, 3);
			"Not scaled damage"
			Start Damage Over Time(Event Player.botSpecialPotentialTargets, Event Player, 3, Event Player.biteDamage * 2);
			If(Event Player.damageOverTimeDuration < 3);
				Event Player.damageOverTimeDuration = 3;
			End;
			Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Position Of(Event Player), 6 * Event Player.size);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Yellow), Position Of(Event Player), 3 * Event Player.size);
			"Scaled"
			Play Effect(All Players(All Teams), Explosion Sound, Color(Yellow), Position Of(Event Player), 150 * Event Player.size);
			"Scaled"
			Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Yellow), Position Of(Event Player), 150 * Event Player.size);
			Wait(0.250, Ignore Condition);
			Abort If(Is Dead(Event Player));
		End;
		If(Array Contains(Global.bosses, Event Player));
			Set Ability Cooldown(Event Player, Button(Ability 2), 20);
			Wait(3, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("BOMBER SHOOTS GRENADES (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Junkrat;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.botTempValue != True;
		Event Player.crowdControlled != True;
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		If(!Event Player.specialThrottling);
			Event Player.specialThrottling = True;
			Stop Throttle In Direction(Event Player);
			Start Holding Button(Event Player, Button(Primary Fire));
		End;
		Set Primary Fire Enabled(Event Player, True);
		Set Projectile Speed(Event Player, Random Real(20, 100));
		Set Projectile Gravity(Event Player, 0);
		Wait(0.016, Ignore Condition);
		Wait Until(!Is Firing Primary(Event Player), 1);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Set Projectile Speed(Event Player, 100);
		Set Projectile Gravity(Event Player, 100);
	}
}

rule("RUSHER (TORB) SPEED MECHANICS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Throttle Of(Event Player) != Vector(0, 0, 0);
		Array Contains(Global.bosses, Event Player) == False;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 45;
	}

	actions
	{
		Apply Impulse(Event Player, Vector(0, 1, 3), 10, To Player, Incorporate Contrary Motion);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("RUSHER MOLTEN CORE (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Ability Cooldown(Event Player, Button(Ability 2)) <= 0;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Set Ultimate Charge(Event Player, 100);
		While(!Is Using Ability 2(Event Player));
			Wait Until(!Is Meleeing(Event Player) && !Event Player.crowdControlled, 9999);
			Press Button(Event Player, Button(Ability 2));
			Wait(0.250, Ignore Condition);
			Abort If(Is Dead(Event Player));
		End;
		Add Health Pool To Player(Event Player, Armor, 1000, False, True);
		Event Player.botTempValue = Last Created Health Pool;
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Wait(1, Ignore Condition);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction From Angles(Evaluate Once(Random Real(0, 360)), Evaluate Once(Random Real(-80, -87))),
			Event Player.crowdControlled ? 0 : 144, To Player, Direction and Turn Rate);
		While(!Is Using Ultimate(Event Player) && Is Alive(Event Player));
			Wait Until(!Is Meleeing(Event Player) && !Event Player.crowdControlled, 9999);
			Press Button(Event Player, Button(Ultimate));
			Wait(0.250, Ignore Condition);
		End;
		Wait(1, Ignore Condition);
		While(Is Using Ultimate(Event Player));
			Press Button(Event Player, Button(Primary Fire));
			Wait(0.250, Ignore Condition);
		End;
		Cancel Primary Action(Event Player);
		Clear Status(Event Player, Rooted);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait Until(!Is Using Ability 2(Event Player), 1);
		Remove Health Pool From Player(Event Player.botTempValue);
		Set Ability Cooldown(Event Player, Button(Ability 2), 10);
		Loop If Condition Is True;
	}
}

rule("RUSHER MOLTEN CORE BURNS PLAYERS (BOSS ONLY)")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		TorbjÃ¶rn;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Start Damage Over Time(Victim, Attacker, 1, Event Player.biteDamage * 0.500);
		Set Status(Victim, Attacker, Burning, 0.500);
		If(Victim.damageOverTimeDuration < 0.500);
			Victim.damageOverTimeDuration = 0.500;
		End;
	}
}

rule("BEHEMOTH (ROAD) TOXIC CLOUD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Roadhog;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Is Alive(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
		(Array Contains(Global.bosses, Event Player) || Normalized Health(Event Player) < 0.500) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Ability 2));
		Wait(0.250, Ignore Condition);
		While(Is Using Ability 2(Event Player));
			If(Array Contains(Global.bosses, Event Player));
				"Charge Ultimate For Boss Gas Attack"
				Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 4);
				Set Status(Event Player, Event Player, Rooted, 0.260);
				Set Ability Cooldown(Event Player, Button(Ability 1), 3);
			Else;
				"Gas Attack"
				Start Damage Over Time(Filtered Array(Global.playerTargetList, Is In Line of Sight(Eye Position(Event Player), Eye Position(
					Current Array Element), Enemy Barriers Block LOS) && Distance Between(Position Of(Event Player), Position Of(
					Current Array Element)) < 10 * Event Player.size && Y Component Of(Eye Position(Current Array Element)) - Y Component Of(
					Position Of(Event Player)) > 0 && Y Component Of(Position Of(Current Array Element)) - Y Component Of(Position Of(
					Event Player)) < 2 * Event Player.size), Event Player, 2.500, Event Player.biteDamage * 0.231);
				If(Event Player.damageOverTimeDuration < 2.500);
					Event Player.damageOverTimeDuration = 2.500;
				End;
				Set Ability Cooldown(Event Player, Button(Ability 1), 8);
			End;
			Wait(0.250, Ignore Condition);
		End;
		If(Array Contains(Global.bosses, Event Player) && Ultimate Charge Percent(Event Player) >= 100);
			Set Ultimate Charge(Event Player, 0);
			Event Player.specialThrottling = True;
			Stop Throttle In Direction(Event Player);
			Event Player.specialFacing = True;
			Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
				Event Player.attached ? 1500 : (Event Player.crowdControlled || Event Player.botTarget == Null ? 0 : 100), To World,
				Direction and Turn Rate);
			Wait(1, Ignore Condition);
			Wait Until(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
				Event Player.lastTarget))) < 5 && Is On Ground(Event Player.lastTarget), 5);
			Stop Facing(Event Player);
			Set Status(Event Player, Null, Stunned, 1);
			Wait Until(!Event Player.crowdControlled, 2);
			Event Player.chase1 = Eye Position(Event Player);
			Event Player.botTempValue = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
				Event Player) * 20 * Event Player.size, Null, All Players(All Teams), False);
			"Launch Gas Projectile"
			Chase Player Variable At Rate(Event Player, chase1, Event Player.botTempValue, 20 * Event Player.size / 3, None);
			Event Player.specialFacing = False;
			Event Player.specialThrottling = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			"Gas Cloud Positions"
			Event Player.abilityArray1 = Empty Array;
			"Gas Cloud Areas of Effect"
			Event Player.abilityArray2 = Empty Array;
			While(Distance Between(Event Player.chase1, Event Player.botTempValue) > 0.100 && Count Of(Event Player.abilityArray1) < 3);
				Modify Player Variable(Event Player, abilityArray1, Append To Array, Event Player.chase1);
				Modify Player Variable(Event Player, abilityArray2, Append To Array, 0);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Event Player.chase1, 0.400 * Event Player.size);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player.chase1, 75);
				Wait Until(Distance Between(Event Player.chase1, Event Player.botTempValue) <= 0.100 || Count Of(Event Player.abilityArray1) >= 3,
					0.900);
			End;
			"If projectile hits wall"
			If(Count Of(Event Player.abilityArray1) < 3);
				Modify Player Variable(Event Player, abilityArray1, Append To Array, Event Player.chase1);
				Modify Player Variable(Event Player, abilityArray2, Append To Array, 0);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Event Player.chase1, 0.400 * Event Player.size);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Lime Green), Event Player.chase1, 75);
			End;
			Stop Chasing Player Variable(Event Player, chase1);
			Event Player.chase1 = Null;
			Wait Until(Is Dead(Event Player), 7);
			Wait(5, Ignore Condition);
			Event Player.abilityArray1 = Empty Array;
			Event Player.abilityArray2 = Empty Array;
		End;
		Loop If Condition Is True;
	}
}

rule("BEHEMOTH GAS STREAM (BOSSES ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Roadhog;
	}

	conditions
	{
		Count Of(Event Player.abilityArray1) > 0;
	}

	actions
	{
		Event Player.botSpecialPotentialTargets = Empty Array;
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.abilityArray1), 1);
			If(Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] < 6 * Event Player.size);
				Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] += 0.200 * Event Player.size;
			End;
			Modify Player Variable(Event Player, botSpecialPotentialTargets, Append To Array, Filtered Array(Global.playerTargetList,
				!Array Contains(Event Player.botSpecialPotentialTargets, Current Array Element) && Distance Between(
				Event Player.abilityArray1[Event Player.pForceFieldCount2_bCount1], Vector(X Component Of(Eye Position(Current Array Element)),
				Y Component Of(Event Player.abilityArray1[Event Player.pForceFieldCount2_bCount1]), Z Component Of(Eye Position(
				Current Array Element)))) < Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] && Absolute Value(
				Y Component Of(Event Player.abilityArray1[Event Player.pForceFieldCount2_bCount1]) - Y Component Of(Eye Position(
				Current Array Element))) < Event Player.abilityArray2[Event Player.pForceFieldCount2_bCount1] / 5));
		End;
		Start Damage Over Time(Event Player.botSpecialPotentialTargets, Event Player, 2.500, Event Player.biteDamage * 0.100);
		If(Event Player.damageOverTimeDuration < 2.500 && Count Of(Event Player.botSpecialPotentialTargets) > 0);
			Event Player.damageOverTimeDuration = 2.500;
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BRUTE (REIN) SUPER SEISMIC SLAM")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reinhardt;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Ultimate Charge Percent(Event Player) >= 100;
		Distance Between(World Vector Of(Vector(0, 0, 3 * Event Player.size), Event Player, Rotation And Translation), Position Of(
			Event Player.botTarget)) < 1.500 * Event Player.size;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Ultimate));
		While(!Is Using Ultimate(Event Player));
			Wait(0.016, Restart When True);
			Abort If(Is Dead(Event Player));
			Abort If(Event Player.crowdControlled);
		End;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), World Vector Of(Vector(0, 0, 3 * Event Player.size),
			Event Player, Rotation And Translation), 20 * Event Player.size);
		Apply Impulse(Filtered Array(Remove From Array(All Living Players(All Teams), Event Player), Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) < 20 * Event Player.size && Distance Between(World Vector Of(Vector(0, 0,
			3 * Event Player.size), Event Player, Rotation And Translation), Position Of(Current Array Element))
			> 1.500 * Event Player.size && Is In Line of Sight(Eye Position(Event Player), Eye Position(Current Array Element),
			Enemy Barriers Block LOS) && Current Array Element != Event Player && Absolute Value(Y Component Of(Position Of(Event Player))
			- Y Component Of(Position Of(Current Array Element))) < 2 * Event Player.size), Vector(0, 1, 0), 15 * Event Player.size,
			To World, Cancel Contrary Motion);
		Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), World Vector Of(Vector(0, 0, 3 * Event Player.size),
			Event Player, Rotation And Translation), 3 * Event Player.size);
		Set Status(Filtered Array(Append To Array(Null, All Living Players(Team 1)), Distance Between(Position Of(Current Array Element),
			World Vector Of(Vector(0, 0, 3 * Event Player.size), Event Player, Rotation And Translation))
			< 1.500 * Event Player.size && !Has Status(Current Array Element, Knocked Down)), Event Player, Knocked Down, 2.500);
		Big Message(Filtered Array(All Living Players(Team 2), Distance Between(World Vector Of(Vector(0, 0, 3 * Event Player.size),
			Event Player, Rotation And Translation), Position Of(Current Array Element)) < 1.500 * Event Player.size), Custom String(
			"Crushed!"));
	}
}

rule("BRUTE HAMMER CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reinhardt;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Distance Between(Eye Position(Event Player), Eye Position(Event Player.botTarget)) < 5 * Event Player.size;
	}

	actions
	{
		Set Primary Fire Enabled(Event Player, True);
		Start Holding Button(Event Player, Button(Primary Fire));
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("BRUTE KNOCKDOWN")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
		Hero Of(Attacker) == Hero(Reinhardt);
	}

	actions
	{
		Set Ultimate Charge(Attacker, Ultimate Charge Percent(Attacker) + 25);
		Apply Impulse(Event Player, Direction Towards(Position Of(Attacker), Position Of(Event Player)) + Vector(0, 0.250, 0),
			15 * Attacker.size, To World, Incorporate Contrary Motion);
		Set Status(Event Player, Null, Knocked Down, 0.500);
		Set Gravity(Event Player, 0);
		Wait(0.350, Ignore Condition);
		Set Gravity(Event Player, 100);
		Wait(2, Ignore Condition);
	}
}

rule("BRUTE FIRE STRIKE (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Reinhardt;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Eye Position(Event Player), Eye Position(Event Player.botTarget)) > 5 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Set Ability Charge(Event Player, Button(Ability 2), 2);
		Press Button(Event Player, Button(Ability 2));
		Wait Until(!Is Using Ability 2(Event Player), 3);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SLICER (GENJI) SUPER JUMP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Genji;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 4 * Event Player.size;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 30 * Event Player.size;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.canWallPhase = False;
		Start Holding Button(Event Player, Button(Crouch));
		Wait(0.500, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Event Player.canWallPhase = True;
		If(Event Player.botTarget != Null && !Event Player.crowdControlled);
			Apply Impulse(Event Player, Normalize(Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget)) + Vector(0,
				0.250, 0)), Event Player.size * (15 + 25 * Absolute Value(Cosine From Degrees(Vertical Angle From Direction(Direction Towards(
				Position Of(Event Player), Position Of(Event Player.botTarget)))))), To World, Incorporate Contrary Motion);
		End;
		Wait(0.250, Ignore Condition);
		Wait Until(Is On Ground(Event Player), 1);
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Loop;
	}
}

rule("RIDER (WIDOWMAKER) ATTACH TO PLAYERS")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Event Ability == Button(Melee);
		Victim == Event Player.botTarget;
		Event Player.attached != True;
		Array Contains(Global.bosses, Event Player) == False;
	}

	actions
	{
		Event Player.attached = True;
		Event Player.botSpecialTarget = Victim;
		Attach Players(Event Player, Event Player.botSpecialTarget, Vector(0, 0, Event Player.botSpecialTarget.size));
	}
}

rule("RIDER DETACH WHEN DEAD OR TARGET IS DEAD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Event Player.attached == True;
		Event Player.botSpecialTarget != Null;
		(Event Player.crowdControlled || Event Player.botSpecialTarget.invisible || Is Dead(Event Player) || Is Dead(
			Event Player.botSpecialTarget) || Has Status(Event Player.botSpecialTarget, Phased Out) || Has Status(
			Event Player.botSpecialTarget, Invincible) || !Entity Exists(Event Player.botSpecialTarget)) == True;
	}

	actions
	{
		Event Player.botSpecialTarget = Null;
		Event Player.attached = False;
		Detach Players(Event Player);
	}
}

rule("RIDER ATTACH TO TEAMMATES")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Event Player.teleporting != True;
		Event Player.attached != True;
		Is Alive(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == False;
		"If any valid teammates are within range"
		Is True For Any(Remove From Array(All Living Players(Team 1), Event Player), !Current Array Element.teleporting && Current Array Element.botThrottleSpeed > Event Player.botThrottleSpeed && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
			< 4 * Event Player.size) == True;
		(Event Player.botTarget == Null || Distance Between(Eye Position(Event Player), Event Player.botTarget) > 20 || (Ability Cooldown(
			Event Player, Button(Ability 1)) > 0 && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			> 7.500)) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.botSpecialTarget = First Of(Sorted Array(Filtered Array(Remove From Array(All Living Players(Team 1), Event Player),
			!Current Array Element.teleporting && Current Array Element.botThrottleSpeed > Event Player.botThrottleSpeed), Distance Between(Position Of(
			Event Player), Position Of(Current Array Element))));
		Attach Players(Event Player, Event Player.botSpecialTarget, Event Player.botSpecialTarget.size * Vector(Random Real(-0.500, 0.500),
			0.250, -0.750));
		Event Player.attached = True;
	}
}

rule("RIDER DETATCH FROM TEAMMATES WHILE ALIVE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Event Player.attached == True;
		Event Player.botTarget != Null;
		Team Of(Event Player.botSpecialTarget) == Team 1;
		(Event Player.teleporting || Event Player.botSpecialTarget.teleporting || Distance Between(Eye Position(Event Player), Position Of(
			Event Player.botTarget)) < 3 || (Is On Ground(Event Player.botTarget) && Ability Cooldown(Event Player, Button(Ability 1))
			== 0 && Distance Between(Eye Position(Event Player), Position Of(Event Player.botTarget)) < 10)) == True;
	}

	actions
	{
		Event Player.botSpecialTarget = Null;
		Event Player.attached = False;
		Detach Players(Event Player);
	}
}

rule("RIDER USE GRAPPLING HOOK")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.attached != True;
		Is On Ground(Event Player.botTarget) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
		Distance Between(Eye Position(Event Player), Position Of(Event Player.botTarget)) < 20;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 5;
	}

	actions
	{
		Event Player.specialFacing = True;
		Event Player.botTempValue = Ray Cast Hit Position(Eye Position(Event Player), Position Of(Event Player.botTarget), Null,
			Event Player, False);
		Stop Facing(Event Player);
		Wait Until(!Event Player.crowdControlled, 2);
		Set Facing(Event Player, Direction Towards(Eye Position(Event Player), Event Player.botTempValue), To World);
		Press Button(Event Player, Button(Ability 1));
		Wait Until(Is Using Ability 1(Event Player), 1);
		Wait(0.250, Ignore Condition);
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait Until(!Is Using Ability 1(Event Player) || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			< 4 || Distance Between(Position Of(Event Player), Event Player.botTempValue) < 3.500, 3);
		If(Is Using Ability 1(Event Player));
			Start Holding Button(Event Player, Button(Jump));
			Wait(0.250, Ignore Condition);
			Stop Holding Button(Event Player, Button(Jump));
		End;
		Set Ability Cooldown(Event Player, Button(Ability 1), 8);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("CHARGER (ORISA) CHARGE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Orisa;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Is On Ground(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Is Using Ability 1(Event Player) == False;
		Throttle Of(Event Player) != Vector(0, 0, 0);
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 35;
		(Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 5 || Vertical Angle From Direction(
			Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget))) > -35) == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.canWallPhase = False;
		Enable Movement Collision With Environment(Event Player);
		Event Player.wallCollisionEnabled = True;
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.attached ? 1500 : (Event Player.crowdControlled ? 0 : 100), To World, Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Vector(0, 0, -1), 0.350, To Player, Replace existing throttle, None);
		"Charger walk backwards duration"
		For Player Variable(Event Player, pNoCooldownsCount_bCount2, 0, 1, 0.064);
			If(Event Player.botTarget == Null && Event Player.botTempValue == Null);
				Event Player.botTempValue = Position Of(Event Player.lastTarget) + Normalize(World Vector Of(Throttle Of(Event Player.lastTarget),
					Event Player.lastTarget, Rotation)) * -2;
				Stop Facing(Event Player);
			Else If(Event Player.botTarget != Null && Event Player.botTempValue != 0);
				Event Player.botTempValue = Null;
			End;
			If(Event Player.crowdControlled || Is Dead(Event Player));
				Event Player.specialFacing = False;
				Event Player.specialThrottling = False;
				Start Rule(restoreDefaultFacingMovement, Do Nothing);
				Abort;
			End;
			Wait(0.064, Ignore Condition);
		End;
		Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player),
			Event Player.botTempValue == Null ? Position Of(Event Player.botTarget) : Event Player.botTempValue),
			Event Player.botThrottleSpeed, To World, Replace existing throttle, None);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Throttle Of(Event Player), 100, To Player, Direction and Turn Rate);
		Event Player.movementSpeed *= 3;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Press Button(Event Player, Button(Ability 1));
		Event Player.botTempValue = 1;
		Wait(0.250, Ignore Condition);
		Event Player.botSpecialPotentialTargets = Empty Array;
		Wait Until(!Is Using Ability 1(Event Player) || (Count Of(Event Player.botSpecialPotentialTargets) == 0 && Speed Of In Direction(
			Event Player, World Vector Of(Throttle Of(Event Player), Event Player, Rotation))
			< Event Player.botThrottleSpeed * 3.500 * Event Player.movementSpeed), 10);
		Event Player.botTempValue = Null;
		"Charge stops early due to hitting object"
		If(Is Using Ability 1(Event Player) && Speed Of In Direction(Event Player, World Vector Of(Throttle Of(Event Player), Event Player,
			Rotation)) < Event Player.botThrottleSpeed * 3.500 * Event Player.movementSpeed);
			"Wall crash light"
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), World Vector Of(Vector(0, 1.500 * Event Player.size,
				Event Player.size), Event Player, Rotation And Translation), Event Player.size);
			"Wall crash sound"
			Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), World Vector Of(Vector(0, 1.500 * Event Player.size,
				Event Player.size), Event Player, Rotation And Translation), 25 * Event Player.size);
			Stop Throttle In Direction(Event Player);
			Stop Facing(Event Player);
			Set Move Speed(Event Player, 100);
			"Boss only"
			If(Array Contains(Global.bosses, Event Player));
				Play Effect(All Players(All Teams), Bad Explosion, Color(White), Position Of(Event Player), 7.500 * Event Player.size);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), Position Of(Event Player), 200);
				Event Player.botSpecialPotentialTargets = Filtered Array(Remove From Array(Append To Array(Global.playerTargetList,
					All Living Players(Team 1)), Event Player), !Has Status(Current Array Element, Phased Out) && Distance Between(Position Of(
					Event Player), Position Of(Current Array Element)) < 7.500 * Event Player.size && Is In Line of Sight(Position Of(Event Player)
					+ Vector(0, Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
					Barriers Do Not Block LOS));
				Set Status(Filtered Array(Event Player.botSpecialPotentialTargets, Distance Between(Position Of(Event Player), Position Of(
					Current Array Element)) < 5 * Event Player.size && Is In Line of Sight(Position Of(Event Player) + Vector(0,
					Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
					Enemy Barriers Block LOS)), Event Player, Knocked Down, 0.500);
				For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
					Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
					Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
						Event Player), Position Of(Event Player.botSpecialTarget))), -10), (Distance Between(Position Of(Event Player), Position Of(
						Event Player.botSpecialTarget)) < 5 * Event Player.size ? 20 : 5) * Event Player.size, To World, Incorporate Contrary Motion);
				End;
			End;
			Wait(1, Ignore Condition);
		End;
		Event Player.movementSpeed /= 3;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Event Player.canWallPhase = True;
		Wait Until(!Is Using Ability 1(Event Player), 10);
		Set Ability Cooldown(Event Player, Button(Ability 1), Array Contains(Global.bosses, Event Player) ? 2 : 5);
	}
}

rule("CHARGER CHARGE IMPULSE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Orisa;
	}

	conditions
	{
		Event Player.botTempValue == 1;
		Is True For Any(Remove From Array(Append To Array(Global.playerTargetList, All Living Players(Team 1)), Event Player), !Has Status(
			Current Array Element, Phased Out) && Distance Between(Position Of(Event Player) + Vector(0, 1.500 * Event Player.size, 0),
			Position Of(Current Array Element) + Vector(0, 1.500 * Current Array Element.size, 0))
			< 2 * Event Player.size && Absolute Value(Angle Between Vectors(World Vector Of(Throttle Of(Event Player), Event Player,
			Rotation), Direction Towards(Position Of(Event Player), Position Of(Current Array Element)))) < 110) == True;
	}

	actions
	{
		Event Player.botSpecialPotentialTargets = Filtered Array(Remove From Array(Append To Array(Global.playerTargetList,
			All Living Players(Team 1)), Event Player), !Has Status(Current Array Element, Phased Out) && Distance Between(Position Of(
			Event Player) + Vector(0, 1.500 * Event Player.size, 0), Position Of(Current Array Element) + Vector(0,
			1.500 * Current Array Element.size, 0)) < 2 * Event Player.size && Absolute Value(Angle Between Vectors(World Vector Of(
			Throttle Of(Event Player), Event Player, Rotation), Direction Towards(Position Of(Event Player), Position Of(
			Current Array Element)))) < 110);
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
			Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
			"Knock players back"
			Apply Impulse(Event Player.botSpecialTarget, Normalize(Direction From Angles(Horizontal Angle From Direction(Direction Towards(
				Position Of(Event Player), Position Of(Event Player.botSpecialTarget))), 0)) + Vector(0, 2, 0) + Normalize(World Vector Of(
				Throttle Of(Event Player), Event Player, Rotation)) * 2, 12 * Event Player.size, To World, Incorporate Contrary Motion);
			"Damage players"
			Damage(Event Player.botSpecialTarget, Event Player, Event Player.biteDamage * 1.500);
		End;
		Wait(0.064, Ignore Condition);
		Loop If Condition Is True;
		Event Player.botSpecialPotentialTargets = Empty Array;
	}
}

rule("CHARGER SPEAR FLIGHT SLAM (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Orisa;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Array Contains(Global.bosses, Event Player) == True;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 35;
		(Distance Between(Vector(X Component Of(Position Of(Event Player)), Y Component Of(Position Of(Event Player.botTarget)),
			Z Component Of(Position Of(Event Player))), Position Of(Event Player.botTarget)) < 6 * Event Player.size) == True;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		While(!Is Using Ability 2(Event Player));
			Press Button(Event Player, Button(Ability 2));
			Wait Until(Is Using Ability 2(Event Player), 0.500);
		End;
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player),
			Eye Position(Event Player.lastTarget))), -1 * Absolute Value(Vertical Angle From Direction(Direction Towards(Eye Position(
			Event Player), Eye Position(Event Player.lastTarget))))), Event Player.crowdControlled ? 0 : 100, To World,
			Direction and Turn Rate);
		While(Is Using Ability 2(Event Player));
			Apply Impulse(Event Player, Facing Direction Of(Event Player), 7.500, To World, Cancel Contrary Motion);
			Wait(0.032, Ignore Condition);
		End;
		Set Ultimate Charge(Event Player, 100);
		Press Button(Event Player, Button(Ultimate));
		Wait Until(Is Using Ultimate(Event Player), 1);
		Wait Until(Is On Ground(Event Player) || !Is Using Ultimate(Event Player), 10);
		While(Is Using Ultimate(Event Player));
			Press Button(Event Player, Button(Primary Fire));
			Wait(0.250, Ignore Condition);
		End;
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Set Ability Cooldown(Event Player, Button(Ability 2), 7);
		Wait Until(Throttle Of(Event Player) != Vector(0, 0, 0), 2);
		If(Throttle Of(Event Player) == Vector(0, 0, 0));
			Start Throttle In Direction(Event Player, Vector(0, 0, 1), Event Player.botThrottleSpeed, To Player, Replace existing throttle,
				None);
		End;
	}
}

rule("SLIMER (MERCY) TENTACLE GRAB")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Mercy;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.botTempValue == Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Is Using Ultimate(Event Player) != True;
		Distance Between(Eye Position(Event Player), Eye Position(Event Player.botTarget)) < 20 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 20;
	}

	actions
	{
		Wait(Is Using Ultimate(Event Player) ? 0.016 : 0.500, Abort When False);
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.botSpecialTarget = Null;
		Event Player.chase1 = Is In Air(Event Player) ? Eye Position(Event Player) + Vector(0, 0.500, 0)
			* Event Player.size : Eye Position(Event Player);
		Event Player.botTempValue = Eye Position(Event Player) + Facing Direction Of(Event Player) * 20 * Event Player.size;
		"Tentacle extends"
		Chase Player Variable At Rate(Event Player, chase1, Event Player.botTempValue, 50, Destination and Rate);
		Wait(0.016, Ignore Condition);
		While(Is Alive(Event Player) && !Event Player.crowdControlled && Distance Between(Eye Position(Event Player),
			Ray Cast Hit Position(Eye Position(Event Player), Event Player.botTempValue, All Living Players(Team 2), All Players(
			All Teams), True)) > Distance Between(Eye Position(Event Player), Event Player.chase1));
			If(Is True For Any(Global.playerTargetList, !Has Status(Current Array Element, Phased Out) && Distance Between(Event Player.chase1,
				Eye Position(Current Array Element)) < 1 && Is In Line of Sight(Event Player.chase1, Eye Position(Current Array Element),
				Enemy Barriers Block LOS)));
				Event Player.botSpecialTarget = First Of(Filtered Array(Global.playerTargetList, !Has Status(Current Array Element, Phased Out)
					&& Distance Between(Event Player.chase1, Eye Position(Current Array Element)) < 1 && Is In Line of Sight(Event Player.chase1,
					Eye Position(Event Player), Enemy Barriers Block LOS)));
				Event Player.botTempValue = Eye Position(Event Player.botSpecialTarget);
				Break;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Lime Green), Event Player.chase1, 0.250);
		"Tentacle retract"
		Chase Player Variable At Rate(Event Player, chase1, Is In Air(Event Player) ? Eye Position(Event Player) + Vector(0, 0.500, 0)
			* Event Player.size : Eye Position(Event Player), 50, Destination and Rate);
		If(Is Alive(Event Player) && !Event Player.crowdControlled && Event Player.botSpecialTarget != Null);
			"Knocks target down if facing away from Mercy"
			If(Absolute Value(Angle Difference(Horizontal Facing Angle Of(Event Player.botSpecialTarget), Horizontal Angle From Direction(
				Direction Towards(Position Of(Event Player), Position Of(Event Player.botSpecialTarget))))) < 75);
				Set Status(Event Player.botSpecialTarget, Null, Knocked Down, 0.350);
			End;
			Set Gravity(Event Player.botSpecialTarget, 0);
			Apply Impulse(Event Player.botSpecialTarget, Direction Towards(Eye Position(Event Player.botSpecialTarget), Eye Position(
				Event Player)), Event Player.size * (Max Health(Event Player.botSpecialTarget) < 400 ? 15 : 10), To World,
				Cancel Contrary Motion);
			Wait(0.350, Ignore Condition);
			Set Gravity(Event Player.botSpecialTarget, 100);
		End;
		While(Distance Between(Event Player.chase1, Is In Air(Event Player) ? Eye Position(Event Player) + Vector(0, 0.500, 0)
			* Event Player.size : Eye Position(Event Player)) > 0.250);
			Wait(0.250, Ignore Condition);
		End;
		Event Player.botTempValue = Null;
		Stop Chasing Player Variable(Event Player, chase1);
		"Lower cooldown for ulting boss if they do not hit a target"
		If(Array Contains(Global.bosses, Event Player) && Is Using Ultimate(Event Player));
			Wait(0.250, Ignore Condition);
		Else;
			Event Player.specialThrottling = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			Wait(4.500, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("SLIMER FLIGHT (BOSS ONLY)")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Mercy;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.botTempValue == Null;
		Event Player.specialThrottling != True;
		Event Player.crowdControlled != True;
		Is On Ground(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Set Primary Fire Enabled(Event Player, True);
		Set Ultimate Charge(Event Player, 100);
		Wait Until(!Has Status(Event Player, Hacked), 1);
		Event Player.specialThrottling = True;
		While(!Is Jumping(Event Player));
			Event Player.wallCollisionEnabled = True;
			Enable Movement Collision With Environment(Event Player);
			Press Button(Event Player, Button(Jump));
			Wait Until(Is Jumping(Event Player), 1);
		End;
		Apply Impulse(Event Player, Vector(0, 1, 0), Random Real(6, 10) * Event Player.size, To World, Cancel Contrary Motion);
		Wait(0.016, Ignore Condition);
		Wait Until(Y Component Of(Velocity Of(Event Player)) < 0, 3);
		Press Button(Event Player, Button(Ultimate));
		Wait Until(Is Using Ultimate(Event Player), 1);
		Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player, 5 * Event Player.size);
		While(Is Using Ultimate(Event Player));
			Event Player.specialThrottling = True;
			Event Player.specialFacing = True;
			Stop Throttle In Direction(Event Player);
			While(Event Player.botTarget != Null && Is Using Ultimate(Event Player) && !Event Player.crowdControlled);
				Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botTarget) + Evaluate Once(
					Direction From Angles(Random Real(0, 360), Random Real(-90, 90))) * 1), Event Player.crowdControlled ? 0 : 200, To World,
					Direction and Turn Rate);
				Press Button(Event Player, Button(Primary Fire));
				"Altitude too low"
				If(Altitude Of(Event Player) < 3);
					Event Player.wallCollisionEnabled = True;
					Enable Movement Collision With Environment(Event Player);
					Press Button(Event Player, Button(Jump));
				End;
				"Entities that will be floated"
				Event Player.botSpecialPotentialTargets = Filtered Array(All Living Players(All Teams),
					Current Array Element != Event Player && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
					< 12 * Event Player.size && Is In Line of Sight(Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
					Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0), Barriers Do Not Block LOS));
				For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
					Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
					If(Y Component Of(Position Of(Event Player.botSpecialTarget)) < Y Component Of(Position Of(Event Player)));
						"Make target float up"
						Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
							Event Player.botSpecialTarget), Position Of(Event Player))), -75), 0.750, To World, Incorporate Contrary Motion);
					Else;
						"Push target away"
						Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
							Event Player), Position Of(Event Player.botSpecialTarget))), -20), 0.750, To World, Incorporate Contrary Motion);
					End;
				End;
				Wait(0.032, Ignore Condition);
			End;
			Event Player.specialThrottling = False;
			Event Player.specialFacing = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			Wait(0.250, Ignore Condition);
		End;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait(10, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("STRIKER (WRECKING BALL) PILE DRIVER")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.specialThrottling != True;
		Has Status(Event Player, Rooted) == False;
		Ability Cooldown(Event Player, Button(Crouch)) <= 0;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 35;
		(Altitude Of(Event Player) > 3 || (Is On Ground(Event Player) && Is In Line of Sight(Eye Position(Event Player), Eye Position(
			Event Player) + Vector(0, 3, 0), Barriers Do Not Block LOS))) == True;
	}

	actions
	{
		Wait(0.125, Abort When False);
		Wait Until(!Has Status(Event Player, Hacked), 1);
		Event Player.botTempValue = True;
		Event Player.canWallPhase = False;
		Event Player.wallCollisionEnabled = True;
		Enable Movement Collision With Environment(Event Player);
		If(Is On Ground(Event Player));
			While(!Is Jumping(Event Player));
				Press Button(Event Player, Button(Jump));
				Wait Until(Is Jumping(Event Player), 1);
			End;
			Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Position Of(Event Player), 4 * Event Player.size);
			Apply Impulse(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget) + Vector(0,
				10 * Event Player.size, 0)), 25, To World, Cancel Contrary Motion);
			Wait(0.250, Ignore Condition);
			Wait Until(Y Component Of(Velocity Of(Event Player)) <= 0, 3);
		End;
		Press Button(Event Player, Button(Crouch));
		Wait Until(!Is Using Ability 1(Event Player) || Event Player.crowdControlled, 5);
		Set Ability Cooldown(Event Player, Button(Crouch), 3);
		Event Player.botTempValue = Null;
		Event Player.canWallPhase = True;
	}
}

rule("STRIKER CANCEL BALL FORM")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Wrecking Ball;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
		Event Player.specialThrottling == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Press Button(Event Player, Button(Ability 1));
		Loop If Condition Is True;
	}
}

rule("STRIKER NORMAL PILE DRIVER")
{
	event
	{
		Player Dealt Knockback;
		Team 1;
		Wrecking Ball;
	}

	conditions
	{
		Event Ability == Button(Crouch);
		Array Contains(Global.bosses, Event Player) != True;
	}

	actions
	{
		Apply Impulse(Victim, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(Attacker), Position Of(
			Victim))), 0), 7.500 * Event Player.size, To World, Incorporate Contrary Motion);
	}
}

rule("STRIKER SUPER PILE DRIVER")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Wrecking Ball;
	}

	conditions
	{
		Event Player.botTempValue != 0;
		Event Player.crowdControlled != True;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Is Using Ability 1(Event Player) == True;
		Array Contains(Global.bosses, Event Player) == True;
	}

	actions
	{
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Position Of(Event Player), 7.500 * Event Player.size);
		Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), Position Of(Event Player), 100);
		Event Player.botSpecialPotentialTargets = Filtered Array(Remove From Array(Append To Array(Global.playerTargetList,
			All Living Players(Team 1)), Event Player), !Has Status(Current Array Element, Phased Out) && Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) < 7.500 * Event Player.size && Is In Line of Sight(Position Of(Event Player)
			+ Vector(0, Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
			Barriers Do Not Block LOS));
		Set Status(Filtered Array(Event Player.botSpecialPotentialTargets, Distance Between(Position Of(Event Player), Position Of(
			Current Array Element)) < 5 * Event Player.size && Is In Line of Sight(Position Of(Event Player) + Vector(0,
			Global.losHeightCheck, 0), Position Of(Current Array Element) + Vector(0, Global.losHeightCheck, 0),
			Enemy Barriers Block LOS)), Event Player, Knocked Down, 0.350);
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Count Of(Event Player.botSpecialPotentialTargets), 1);
			Event Player.botSpecialTarget = Event Player.botSpecialPotentialTargets[Event Player.pForceFieldCount2_bCount1];
			Apply Impulse(Event Player.botSpecialTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(
				Event Player), Position Of(Event Player.botSpecialTarget))), -25), (Distance Between(Position Of(Event Player), Position Of(
				Event Player.botSpecialTarget)) < 5 * Event Player.size ? 15 : 7.500) * Event Player.size, To World, Cancel Contrary Motion);
		End;
	}
}

rule("STALKER (MOIRA) FADE")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Moira;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.wallCollisionEnabled == True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 45;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.specialFacing = True;
		Event Player.playerCollisionEnabled = False;
		Disable Movement Collision With Players(Event Player);
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.crowdControlled || Is Using Ultimate(Event Player) ? 0 : (Is Using Ability 1(Event Player) ? 75 : 1500), To World,
			Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, Direction and Magnitude);
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Array Contains(Global.bosses, Event Player) ? 5 : 3, 1);
			Event Player.canWallPhase = False;
			Event Player.wallCollisionEnabled = True;
			Enable Movement Collision With Environment(Event Player);
			"Final fade"
			If(Event Player.pForceFieldCount2_bCount1 >= 2 && !Array Contains(Global.bosses, Event Player));
				Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
					Event Player.crowdControlled ? 0 : 100, To World, Direction and Turn Rate);
				Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.lastTarget)),
					Distance Between(Position Of(Event Player), Position Of(Event Player.lastTarget)) < 3 && Is Using Ability 1(Event Player)
					? 0 : Event Player.botThrottleSpeed, To World, Replace existing throttle, Direction and Magnitude);
			End;
			Event Player.movementSpeed *= 2;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			Press Button(Event Player, Button(Ability 1));
			Wait(0.125, Ignore Condition);
			Wait Until(!Is Using Ability 1(Event Player), 2);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Event Player.movementSpeed /= 2;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			If(Is Dead(Event Player) || Event Player.crowdControlled || Has Status(Event Player, Hacked));
				Break;
			End;
			If(Array Contains(Global.bosses, Event Player));
				Wait(0.125, Ignore Condition);
				Set Ultimate Charge(Event Player, 100);
				Press Button(Event Player, Button(Ultimate));
				Set Status(Event Player, Null, Rooted, 1);
				Wait Until(!Is Using Ultimate(Event Player), 1.100);
				Cancel Primary Action(Event Player);
			Else;
				Event Player.canWallPhase = True;
				Wait(0.750, Ignore Condition);
			End;
		End;
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Event Player.canWallPhase = True;
		Enable Movement Collision With Players(Event Player);
		Event Player.playerCollisionEnabled = True;
		Set Ability Cooldown(Event Player, Button(Ability 1), Array Contains(Global.bosses, Event Player) ? 10 : 5);
	}
}

rule("STALKER KNOCKBACK BLAST (BOSS ONLY)")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Moira;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Apply Impulse(Victim, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Position Of(Attacker), Position Of(
			Victim))), -25), 10 * Attacker.size, To World, Cancel Contrary Motion);
		If(!Has Status(Victim, Knocked Down));
			Set Status(Victim, Null, Knocked Down, 0.500);
	}
}

rule("HOPPER (D.VA) JUMPS AROUND")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.wallCollisionEnabled == True;
		Is In Alternate Form(Event Player) == False;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 15 * Event Player.size;
		Absolute Value(Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Event Player.botTarget)))) < 15;
	}

	actions
	{
		Set Gravity(Event Player, 150);
		Event Player.movementSpeed *= 1.600;
		Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.crowdControlled ? 0 : (Horizontal Speed Of(Event Player)
			< 3.500 * Event Player.botThrottleSpeed * Event Player.movementSpeed ? 500 : 60), To World, Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, Direction and Magnitude);
		"Hop amount"
		For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, 8, 1);
			Set Jump Vertical Speed(Event Player, 110 + Event Player.pForceFieldCount2_bCount1 * 35);
			While(Is Alive(Event Player) && !Is In Air(Event Player));
				Wait Until(!Event Player.crowdControlled, 99999);
				Press Button(Event Player, Button(Jump));
				Wait(0.016, Ignore Condition);
			End;
			Wait(0.500, Ignore Condition);
			Wait Until(Is On Ground(Event Player) || Is Dead(Event Player) || Is In Alternate Form(Event Player) || Has Status(Event Player,
				Hacked) || Event Player.crowdControlled, 99999);
			If(Is Dead(Event Player) || Is In Alternate Form(Event Player) || Has Status(Event Player, Hacked)
				|| Event Player.crowdControlled);
				Break;
			End;
		End;
		Set Gravity(Event Player, 100);
		Set Jump Vertical Speed(Event Player, 100);
		Event Player.movementSpeed /= 1.600;
		Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Wait(5, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("HOPPER DIES TO ENVIRONMENT")
{
	event
	{
		Player Died;
		Team 1;
		D.Va;
	}

	conditions
	{
		Event Was Environment == True;
		Event Player.botTempValue < 3;
	}

	actions
	{
		"Indicate that remech is needed"
		Event Player.botTempValue = 0;
	}
}

rule("HOPPER SPAWNS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Event Player.initializing != True;
		Event Player.botTempValue < 2;
	}

	actions
	{
		"Indicate that D.Va may need to remech"
		Event Player.botTempValue = 1;
		"Boss only"
		If(Array Contains(Global.bosses, Event Player));
			Set Player Health(Event Player, Event Player.bossHealth);
		End;
		If(Is In Alternate Form(Event Player));
			Wait Until(Is On Ground(Event Player), 99999);
			Set Damage Received(Event Player, 0);
			"Always remech"
			While(Is In Alternate Form(Event Player));
				Set Ultimate Charge(Event Player, 100);
				Press Button(Event Player, Button(Ultimate));
				Wait(0.250, Ignore Condition);
			End;
			Wait Until(!Is Using Ultimate(Event Player), 3.100);
		End;
		Set Damage Received(Event Player, 100);
		"D.Va is in mech"
		Event Player.botTempValue = 2;
		"Boss only"
		If(Array Contains(Global.bosses, Event Player));
			Set Player Health(Event Player, Event Player.bossHealth);
		End;
		Loop If Condition Is True;
	}
}

rule("HOPPER DEMECH INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Event Player.initializing != True;
		Event Player.botTempValue == 2;
		Is Alive(Event Player) == True;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		"D.Va is in alternate form and does not need to remech"
		Event Player.botTempValue = 3;
		Event Player.movementSpeed *= 2.500;
		Set Move Speed(Event Player, 100 * Event Player.movementSpeed);
		Disable Movement Collision With Players(Event Player);
		Event Player.playerCollisionEnabled = False;
		Event Player.health /= 4;
		Event Player.size /= 1.250;
		Start Scaling Player(Event Player, Event Player.size, False);
		Apply Impulse(Event Player, Vector(0, 1, 0), 15, To Player, Cancel Contrary Motion);
		Wait Until(Is In Alternate Form(Event Player), 5);
		Wait(0.250, Ignore Condition);
		If(Array Contains(Global.bosses, Event Player));
			Event Player.bossHealth = Event Player.health;
			"Adjust recorded boss height"
			Global.bosses[1] = Distance Between(Position Of(Event Player), Eye Position(Event Player));
		End;
	}
}

rule("HOPPER DEMECH CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Event Player.botTempValue == 3;
		Event Player.botTarget != Null;
		Is In Alternate Form(Event Player) == True;
	}

	actions
	{
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.botTarget)),
			Event Player.crowdControlled ? 0 : (Horizontal Speed Of(Event Player)
			< 3.500 * Event Player.botThrottleSpeed * Event Player.movementSpeed ? 500 : 100), To World, Direction and Turn Rate);
		Event Player.specialThrottling = True;
		Start Throttle In Direction(Event Player, Facing Direction Of(Event Player), Event Player.botThrottleSpeed, To World,
			Replace existing throttle, Direction and Magnitude);
		Wait Until(Event Player.botTarget == Null, 99999);
		Event Player.specialFacing = False;
		Event Player.specialThrottling = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Loop If Condition Is True;
	}
}

rule("BLASTER (PHARAH) CHARGES ROCKET THEN FIRES")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Pharah;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
	}

	actions
	{
		Event Player.specialThrottling = True;
		Stop Throttle In Direction(Event Player);
		Event Player.specialFacing = True;
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget)),
			Event Player.crowdControlled || (Is On Ground(Event Player) && Event Player.botTarget == Null) ? 0 : 100, To World,
			Direction and Turn Rate);
		Event Player.chase1 = 0;
		Set Damage Received(Event Player, 50);
		"charge up attack"
		Chase Player Variable Over Time(Event Player, chase1, 2, Array Contains(Global.bosses, Event Player) ? 2 : 2, None);
		Wait Until(Is Dead(Event Player) || Event Player.chase1 >= 2, 99999);
		Stop Chasing Player Variable(Event Player, chase1);
		If(Is Dead(Event Player));
			Set Damage Received(Event Player, 100);
			Event Player.chase1 = 0;
			Event Player.specialThrottling = False;
			Event Player.specialFacing = False;
			Abort;
		Else;
			"charge up attack"
			Chase Player Variable Over Time(Event Player, chase1, 0, 0.250, None);
		End;
		Set Damage Received(Event Player, 100);
		Wait Until(Is Dead(Event Player) || Event Player.chase1 <= 0, 99999);
		If(Is Dead(Event Player));
			Event Player.specialThrottling = False;
			Event Player.specialFacing = False;
			Abort;
		End;
		If(Is In Line of Sight(Position Of(Event Player), Eye Position(Event Player) + World Vector Of(Vector(0, 11, 5), Event Player,
			Rotation), Barriers Do Not Block LOS) && Is In Line of Sight(Eye Position(Event Player.lastTarget), Eye Position(Event Player)
			+ World Vector Of(Vector(0, 11, 5), Event Player, Rotation), Barriers Do Not Block LOS));
			Wait Until(!Event Player.crowdControlled, 9999);
			Start Throttle In Direction(Event Player, Vector(0, 0, 1), 1, To Player, Replace existing throttle, None);
			Press Button(Event Player, Button(Ability 1));
			Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
			Wait(0.016, Ignore Condition);
			Wait Until(Vertical Speed Of(Event Player) <= 0, 99999);
			Stop Throttle In Direction(Event Player);
			"Cooldown after flying"
			Set Ability Cooldown(Event Player, Button(Ability 1), 2);
		Else;
			"Cooldown after staying on ground"
			Set Ability Cooldown(Event Player, Button(Ability 1), 1);
		End;
		If(Array Contains(Global.bosses, Event Player));
			While(!Is Using Ultimate(Event Player) && Is Alive(Event Player));
				Set Ultimate Charge(Event Player, 100);
				Set Projectile Speed(Event Player, 35);
				Press Button(Event Player, Button(Ultimate));
				Wait(0.250, Ignore Condition);
			End;
			Wait Until(!Is Using Ultimate(Event Player), 5);
			Set Ability Cooldown(Event Player, Button(Ability 1), 4);
		Else;
			Set Primary Fire Enabled(Event Player, True);
			Press Button(Event Player, Button(Primary Fire));
		End;
		Wait(0.500, Ignore Condition);
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
		Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Position Of(Event Player.botTarget)),
			Event Player.botThrottleSpeed, To World, Replace existing throttle, Direction and Magnitude);
	}
}

rule("BLASTER ROCKET HITS TARGET")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Pharah;
	}

	conditions
	{
		(Event Ability == Button(Primary Fire) || Event Ability == Button(Ultimate)) == True;
	}

	actions
	{
		If(Event Ability == Button(Ultimate));
			Start Damage Over Time(Victim, Event Player, 2, Event Player.biteDamage * 0.500);
			Set Status(Victim, Event Player, Burning, 2);
			If(Event Player.damageOverTimeDuration < 2);
				Event Player.damageOverTimeDuration = 2;
			End;
		Else If(Event Ability == Button(Primary Fire));
			Start Damage Over Time(Victim, Event Player, 1, Event Player.biteDamage);
			Set Status(Victim, Event Player, Burning, 1);
			If(Event Player.damageOverTimeDuration < 1);
				Event Player.damageOverTimeDuration = 1;
			End;
		End;
	}
}

rule("NANOMANCER (RAMATTRA) FIRES NANITE SWARM")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Ramattra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.botTempValue != True;
		Is Using Ability 1(Event Player) != True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 25;
	}

	actions
	{
		If(!Is Button Held(Event Player, Button(Primary Fire)));
			Event Player.specialThrottling = True;
			Stop Throttle In Direction(Event Player);
			Event Player.specialFacing = True;
			Start Facing(Event Player, Direction From Angles(Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player),
				Position Of(Event Player.botTarget) + Vector(0, 1 * Event Player.botTarget.size, 0))) + 3 * Sine From Degrees(
				Total Time Elapsed * 150), Vertical Angle From Direction(Direction Towards(Eye Position(Event Player), Position Of(
				Event Player.botTarget) + Vector(0, 1 * Event Player.botTarget.size, 0)))), Event Player.crowdControlled ? 0 : 200, To World,
				Direction and Turn Rate);
			Set Primary Fire Enabled(Event Player, True);
			Set Projectile Speed(Event Player, 10);
			Start Holding Button(Event Player, Button(Primary Fire));
		End;
		Wait Until(Event Player.botTarget == Null || Is Using Ability 1(Event Player), 1);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
		Event Player.specialThrottling = False;
		Event Player.specialFacing = False;
		Start Rule(restoreDefaultFacingMovement, Do Nothing);
	}
}

rule("NANOMANCER TRANSFORMS")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Ramattra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Is Using Ability 1(Event Player) != True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 12 * Event Player.size;
	}

	actions
	{
		Wait Until(Event Player.botTarget != Null && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			< 5 * Event Player.size, 3);
		Abort If(Event Player.botTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			>= 12 * Event Player.size);
		Event Player.botTempValue = True;
		"Non-bosses get increased health"
		If(!Array Contains(Global.bosses, Event Player));
			Event Player.health *= 6;
			Start Heal Over Time(Event Player, Null, 3, (Event Player.health - Health(Event Player)) / 3);
		End;
		Set Projectile Speed(Event Player, 100);
		Set Melee Enabled(Event Player, False);
		Event Player.damageDealt /= 1;
		Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		While(Event Player.botTarget != Null && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			< 12 * Event Player.size);
			While(!Is Using Ability 1(Event Player));
				Set Ability Cooldown(Event Player, Button(Ability 1), 0);
				Press Button(Event Player, Button(Ability 1));
				Wait Until(Is Using Ability 1(Event Player), 0.250);
			End;
			Wait Until(!Is Using Ability 1(Event Player), 30);
			Wait(0.125, Ignore Condition);
		End;
		Set Melee Enabled(Event Player, True);
		Event Player.damageDealt *= 1;
		Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		If(!Array Contains(Global.bosses, Event Player));
			Event Player.health /= 6;
		End;
		Event Player.botTempValue = False;
		Wait(6, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("NANOMANCER PUNCHES IN NEMESIS FORM")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Ramattra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		Event Player.crowdControlled != True;
		Event Player.botSpecialTarget != True;
		Is Using Ability 1(Event Player) == True;
		Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 8 * Event Player.size;
	}

	actions
	{
		Press Button(Event Player, Button(Primary Fire));
		Wait(0.6, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("ILLUISONIST (SOMBRA) ACTIVATES INVISIBILITY ILLUSION")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Event Player.crowdControlled != True;
		Event Player.initializing != True;
		Event Player.teleporting != True;
		Ability Cooldown(Event Player, Button(Ability 1)) <= 0;
		(Event Player.botTarget == Null || Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget))
			> 3 * Event Player.size) == True;
		Array Contains(Global.bosses, Event Player) != True;
	}

	actions
	{
		Wait(1, Abort When False);
		While(!Is Using Ability 1(Event Player));
			Press Button(Event Player, Button(Ability 1));
			Wait Until(Is Using Ability 1(Event Player), 0.500);
		End;
		Event Player.movementSpeed /= 1.600;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Wait Until(!Is Using Ability 1(Event Player), 9999);
		Event Player.movementSpeed *= 1.600;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
		Set Ability Cooldown(Event Player, Button(Ability 1), 2);
	}
}

rule("ILLUISONIST USES EMP")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sombra;
	}

	conditions
	{
		Event Player.botTarget != Null;
		((Array Contains(Global.bosses, Event Player) && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 20) || (Is Using Ability 1(Event Player) && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) > 7.5 && Distance Between(Position Of(Event Player), Position Of(Event Player.botTarget)) < 30)) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
		Event Player.botSpecialPotentialTargets = Empty Array;
		If(Array Contains(Global.bosses, Event Player));
			Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Position Of(Event Player), 2 * Event Player.size);
			Apply Impulse(Event Player, Vector(0, 1, 0), 4 * Event Player.size, To World, Cancel Contrary Motion);
			Wait(0.125, Ignore Condition);
			Wait Until(Y Component Of(Velocity Of(Event Player)) <= 0, 5);
		Else;
		 	Event Player.specialFacing = True;
			Stop Facing(Event Player);
			Set Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player.lastTarget) + Vector(0, 10, 0)), To World);
			Wait(0.125, Ignore Condition);
			While(!Is Using Ability 2(Event Player));
				Press Button(Event Player, Button(Ability 2));
				Wait(0.125, Ignore Condition);
			End;
			Event Player.specialFacing = False;
			Start Rule(restoreDefaultFacingMovement, Do Nothing);
			Wait(1.5, Ignore Condition);
			Event Player.botTempValue = Position Of(Event Player);
			While(Is Using Ability 2(Event Player));
				Press Button(Event Player, Button(Ability 2));
				Wait(0.125, Ignore Condition);
			End;
			Set Invisible(Event Player, All);
			Wait(0.25, Ignore Condition);
		End;
		"Is boss or translocator has not been destroyed"
		If(Array Contains(Global.bosses, Event Player) || Distance Between(Position Of(Event Player), Event Player.botTempValue) > 1);
			Event Player.damageDealt = 0.010;
			Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
			While(Ultimate Charge Percent(Event Player) >= 100);
				Press Button(Event Player, Button(Ultimate));
				Wait(0.125, Ignore Condition);
			End;
			"EMP Cast"
			Wait(0.360, Ignore Condition);
			"Restore normal damage"
			Event Player.damageDealt = Global.damageDealt[Index Of Array Value(Global.botHeros, Hero Of(Event Player))] / 100;
			Set Damage Dealt(Event Player, Event Player.damageDealt * 100);
		End;
		If(!Array Contains(Global.bosses, Event Player));
			Wait(0.125, Ignore Condition);
			Teleport(Event Player, Event Player.botTempValue);
			Set Invisible(Event Player, None);
			Event Player.pForceFieldCount2_bCount1 = 5;
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Else;
			Event Player.pForceFieldCount2_bCount1 = 10;
		End;
		Event Player.damageOverTimeDuration = EventPlayer.pForceFieldCount2_bCount1 + 0.5;
		While(Event Player.pForceFieldCount2_bCount1 > 0);
			Event Player.botSpecialPotentialTargets.blinded = True;
			Event Player.botSpecialPotentialTargets.updateOutlines = True;
			Wait(0.500, Ignore Condition);
			Event Player.pForceFieldCount2_bCount1 -= 0.500;
		End;
		Event Player.botSpecialPotentialTargets.blinded = False;
		Event Player.botSpecialPotentialTargets.updateOutlines = True;
		Event Player.botSpecialPotentialTargets = Empty Array;
		If(Array Contains(Global.bosses, Event Player));
			Wait(5, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("ILLUSIONIST HITS TARGET WITH EMP")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Sombra;
	}

	conditions
	{
		Event Ability == Button(Ultimate);
	}

	actions
	{
		Modify Player Variable(Attacker, botSpecialPotentialTargets, Append To Array, Victim);
	}
}

disabled rule("============================================== SUPPLY DROPS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("GENERATE SUPPLY DROPS")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"Only activates if last supply drop has been opened"
		Global.supplyDropStatus == True;
		"Waits for all objectives to be determined before activating"
		Global.gameStatus == True;
		Count Of(Global.availablePowerups) > 0;
		"Limited to 12 power ups on the ground at a time"
		Count Of(Global.powerUpPositions) < 12;
	}

	actions
	{
		"Standard 30 second wait"
		Wait(30, Ignore Condition);
		Global.supplyDropLanding = Null;
		Global.supplyDropPosition = Null;
		Global.supplyDropStatus = False;
		"Wait standard minimum 30 seconds + a random 30 to 90 extra seconds. Total resulting wait time is 2 to 3 minutes."
		Wait(Random Real(1.500, 2.500) * 60, Ignore Condition);
		While(Global.supplyDropLanding == Null);
			"Find the closest player to the objective"
			Global.closestPlayerToObjective = First Of(Sorted Array(Global.playerTargetList, Distance Between(Position Of(
				Current Array Element), First Of(Global.objectivePositions))));
			Global.testPos = Random Value In Array(Filtered Array(Global.mapGrid, Distance Between(Position Of(
				Global.closestPlayerToObjective), Current Array Element) < 35 && Distance Between(Position Of(Global.closestPlayerToObjective),
				Current Array Element) > 20));
			If(Is True For All(Global.playerTargetList, Distance Between(Global.testPos, Position Of(Current Array Element)) > 20));
				"Sets supply drop location"
				Global.supplyDropLanding = Global.testPos;
				"Sets supply drop location to be placed on ground (in the case that a walkable position is underground for some reason)"
				Global.supplyDropLanding = Ray Cast Hit Position(Global.supplyDropLanding + Vector(0, 2, 0), Global.supplyDropLanding + Vector(0,
					0, 0), All Players(All Teams), All Players(All Teams), False);
			End;
			Wait(0.250, Ignore Condition);
		End;
		Global.supplyDropPosition = Global.supplyDropLanding + Vector(0, 200, 0);
		Chase Global Variable Over Time(supplyDropPosition, Global.supplyDropLanding, 15, Destination and Duration);
		Big Message(All Players(Team 2), Custom String("Supply drop incoming!"));
		Wait Until(Global.supplyDropPosition == Global.supplyDropLanding, 99999);
		Stop Chasing Global Variable(supplyDropPosition);
		Play Effect(All Players(Team 2), Ring Explosion, Color(Aqua), Global.supplyDropLanding, 4);
		Play Effect(All Players(Team 2), Ring Explosion Sound, Color(White), Global.supplyDropLanding, 50);
		Wait(10, Restart When True);
		Loop If(Count Of(Global.powerUpPositions) < 12);
	}
}

rule("EFFECT/TEXT (GLOBAL)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Count Of(Global.availablePowerups) > 0;
	}

	actions
	{
		"Closed supply drop orb"
		Create Effect(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && !Global.supplyDropStatus), Orb, Color(
			Aqua), Global.supplyDropPosition, 1, Visible To Position and Radius);
		"Falling supply drop aura"
		Create Effect(Filtered Array(All Players(All Teams),
			Global.supplyDropLanding != Null && Global.supplyDropPosition != Null && Distance Between(Global.supplyDropLanding,
			Global.supplyDropPosition) > 1), Bad Aura, Color(Aqua), Global.supplyDropPosition, 1, Visible To Position and Radius);
		"Open supply drop sphere"
		Create Effect(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && Global.supplyDropStatus), Sphere, Color(
			Aqua), Global.supplyDropPosition, 0.500, Visible To Position and Radius);
		"Supply drop landing ring"
		Create Effect(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null), Ring, Color(Aqua),
			Global.supplyDropLanding, 2, Visible To Position and Radius);
		"Open supply drop text"
		Create In-World Text(Filtered Array(All Living Players(Team 2), Global.supplyDropLanding != Null && Distance Between(
			Global.supplyDropLanding, Global.supplyDropPosition) < 1 && !Global.supplyDropStatus && Distance Between(Position Of(
			Current Array Element), Global.supplyDropLanding) <= 6 && Distance Between(Global.supplyDropLanding, Eye Position(
			Current Array Element) + Facing Direction Of(Current Array Element) * Distance Between(Eye Position(Current Array Element),
			Global.supplyDropLanding)) < 0.500), Custom String("[{0}]", Input Binding String(Button(Interact))),
			Global.supplyDropPosition + Vector(0, 1, 0), 2, Do Not Clip, Visible To Position and String, Color(Blue), Default Visibility);
		"Pick up power up text"
		Create In-World Text(Count Of(Filtered Array(Global.powerUpPositions, Distance Between(Current Array Element, Eye Position(
			Local Player) + Facing Direction Of(Local Player) * Distance Between(Eye Position(Local Player), Current Array Element))
			< 0.500 && Distance Between(Position Of(Local Player), Current Array Element) <= 6)) ? Local Player : Null, Custom String(
			"[{0}]", Input Binding String(Button(Interact))), Vector(0, 0.500, 0) + First Of(Sorted Array(Filtered Array(
			Global.powerUpPositions, Distance Between(Current Array Element, Eye Position(Local Player) + Facing Direction Of(Local Player)
			* Distance Between(Eye Position(Local Player), Current Array Element)) < 0.500 && Distance Between(Position Of(Local Player),
			Current Array Element) <= 6), Angle Between Vectors(Facing Direction Of(Local Player), Direction Towards(Eye Position(
			Local Player), Current Array Element)))), 2, Do Not Clip, Visible To Position and String, Color(Green), Default Visibility);
		"Supply drop landing icon"
		Create Icon(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && Distance Between(Position Of(
			Current Array Element), Global.supplyDropPosition) > 5), Global.supplyDropPosition + Vector(0, 1, 0), Plus,
			Visible To and Position, Color(Aqua), True);
		"Supply drop distance"
		Create In-World Text(Filtered Array(All Players(All Teams), Global.supplyDropLanding != Null && Distance Between(Position Of(
			Current Array Element), Global.supplyDropPosition) > 5), Custom String("Supply Drop: {0}m", Distance Between(Position Of(
			Local Player), Global.supplyDropPosition)), Global.supplyDropPosition, 1, Do Not Clip, Visible To Position and String, Color(
			Aqua), Visible Never);
	}
}

rule("PLAYER INTERACT (1: OPEN SUPPLY DROP, 2: PICK UP POWER UP, 3: USE POWER UP)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Alive(Event Player) == True;
		Global.gameStatus == True;
	}

	actions
	{
		If(Distance Between(Global.supplyDropLanding, Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(
			Eye Position(Event Player), Global.supplyDropLanding)) < 0.500 && !Global.supplyDropStatus && Distance Between(Position Of(
			Event Player), Global.supplyDropLanding) <= 6 && Global.supplyDropLanding != Null && Distance Between(Global.supplyDropLanding,
			Global.supplyDropPosition) < 1);
			Global.supplyDropStatus = True;
			Play Effect(All Players(Team 2), Good Explosion, Color(Aqua), Global.supplyDropPosition, 0.500);
			Play Effect(All Players(Team 2), Buff Explosion Sound, Color(Aqua), Global.supplyDropPosition, 50);
			"Power ups per supply drop"
			For Global Variable(count1, 0, Global.numberOfPowerUpsPerSupplyDrop, 1);
				"Range of power ups"
				Modify Global Variable(powerUpIDs, Append To Array, Random Value In Array(Global.availablePowerups));
			End;
			"Spacing of power ups"
			For Player Variable(Event Player, pPowerUpCount_bTeleCount, -60, 61, 120 / (Global.numberOfPowerUpsPerSupplyDrop - 1));
				Modify Global Variable(powerUpPositions, Append To Array, Global.supplyDropLanding + Direction From Angles(
					Horizontal Angle From Direction(Direction Towards(Global.supplyDropLanding, Position Of(Event Player)))
					+ Event Player.pPowerUpCount_bTeleCount, 0) * 2);
			End;
		Else If(Count Of(Global.powerUpPositions) > 0 && Count Of(Filtered Array(Global.powerUpPositions, Distance Between(
				Current Array Element, Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(Eye Position(
				Event Player), Current Array Element)) < 0.500 && Distance Between(Position Of(Event Player), Current Array Element) <= 6))
				> 0);
			"Power up effect position"
			Event Player.powerUpTradeValues[0] = First Of(Sorted Array(Filtered Array(Global.powerUpPositions, Distance Between(
				Current Array Element, Eye Position(Event Player) + Facing Direction Of(Event Player) * Distance Between(Eye Position(
				Event Player), Current Array Element)) < 0.500 && Distance Between(Position Of(Event Player), Current Array Element) <= 6),
				Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player),
				Current Array Element))));
			"Current power up (or 0 if no current power up)"
			Event Player.powerUpTradeValues[2] = Event Player.currentPowerUp;
			Wait(0.016, Ignore Condition);
			"Index of position of current power up being aquired"
			Event Player.powerUpTradeValues[1] = Index Of Array Value(Global.powerUpPositions, First Of(Event Player.powerUpTradeValues));
			Wait(0.016, Ignore Condition);
			"Pick up power up"
			Event Player.currentPowerUp = Global.powerUpIDs[Event Player.powerUpTradeValues[1]];
			Destroy Effect(Global.powerUpEffect[Event Player.powerUpTradeValues[1]]);
			Destroy In-World Text(Global.powerUpText[Event Player.powerUpTradeValues[1]]);
			Wait(0.016, Ignore Condition);
			Modify Global Variable(powerUpIDs, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Modify Global Variable(powerUpPositions, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Modify Global Variable(powerUpEffect, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Modify Global Variable(powerUpText, Remove From Array By Index, Event Player.powerUpTradeValues[1]);
			Wait(0.016, Ignore Condition);
			"Trade power ups. Ignore if no power up is currently held."
			If(Event Player.powerUpTradeValues[2] != 0);
				Modify Global Variable(powerUpIDs, Append To Array, Event Player.powerUpTradeValues[2]);
				Modify Global Variable(powerUpPositions, Append To Array, First Of(Event Player.powerUpTradeValues));
			End;
		Else If(Event Player.currentPowerUp != 0);
			Wait(0.250, Abort When False);
			Call Subroutine(powerUpUsage);
		Else If(Array Contains(Array(Custom String("Mazattack")), Custom String("{0}", Event Player)) && !String Contains(Custom String(
				"{0}", Host Player), Custom String("Mazattack")) && Is Button Held(Event Player, Button(Primary Fire)) && Is Button Held(
				Event Player, Button(Secondary Fire)) && Is Button Held(Event Player, Button(Jump)));
			Wait(1, Abort When False);
			Small Message(All Players(All Teams), Custom String("This game will shut down..."));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("Goodbye!"));
			Wait(1, Ignore Condition);
			Remove Player(All Players(All Teams));
	}
}

disabled rule("============================================== POWER UPS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("POWER UP EFFECT/TEXT MANAGEMENT")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Count Of(Global.powerUpPositions) > Count Of(Global.powerUpEffect);
		Count Of(Global.availablePowerups) > 0;
	}

	actions
	{
		Call Subroutine(powerUpAssignment);
		Modify Global Variable(powerUpEffect, Append To Array, Last Created Entity);
		Modify Global Variable(powerUpText, Append To Array, Last Text ID);
		Loop If Condition Is True;
	}
}

rule("EFFECT/TEXT (PERMANENT)")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.gameStatus == True;
		Count Of(Global.availablePowerups) > 0;
	}

	actions
	{
		"Cure hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 1), Custom String("CURE"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to stop all damage over time and cure yourself", Input Binding String(Button(Interact))), Left, 100, Color(Green),
			Color(Green), Color(Green), Visible To and String, Default Visibility);
		"Revive hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 2), Custom String("REVIVE"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Look at a teammate and hold [{0}] to revive them", Input Binding String(Button(Interact))), Left, 100, Color(Yellow), Color(
			Yellow), Color(Yellow), Visible To and String, Default Visibility);
		"Force field hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 3), Custom String(
			"Force Field"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a force field", Input Binding String(Button(Interact))), Left, 100, Color(Blue), Color(Blue), Color(Blue),
			Visible To and String, Default Visibility);
		"No cooldowns hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 4), Custom String(
			"No Cooldowns"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to get fast cooldowns", Input Binding String(Button(Interact))), Left, 100, Color(Red), Color(Red), Color(Red),
			Visible To and String, Default Visibility);
		"Air strike hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 5), Custom String("Air Strike"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to call in an air strike", Input Binding String(Button(Interact))), Left, 100, Color(Orange), Color(Orange), Color(
			Orange), Visible To and String, Default Visibility);
		"Heal beacon hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 6), Custom String(
			"Healing Beacon"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a healing beacon", Input Binding String(Button(Interact))), Left, 100, Color(Yellow), Color(Yellow),
			Color(Yellow), Visible To and String, Default Visibility);
		"Vaccine hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 7), Custom String("VACCINE"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to increase your resistance to infection", Input Binding String(Button(Interact))), Left, 100, Color(Green), Color(
			Green), Color(Green), Visible To and String, Default Visibility);
		"Sentry turret hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 8), Custom String(
			"Sentry Turret"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a sentry turret", Input Binding String(Button(Interact))), Left, 100, Color(Orange), Color(Orange), Color(
			Orange), Visible To and String, Default Visibility);
		"Cloaking Device hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 9), Custom String(
			"Cloaking Device"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to become invisible to enemies", Input Binding String(Button(Interact))), Left, 100, Color(Blue), Color(Blue),
			Color(Blue), Visible To and String, Default Visibility);
		"Super Nano hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 10), Custom String(
			"Super Nano"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to increase your damage and speed", Input Binding String(Button(Interact))), Left, 100, Color(Red), Color(Red),
			Color(Red), Visible To and String, Default Visibility);
		"Bounce Pad hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 11), Custom String(
			"Bounce Pad"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to place a bounce pad", Input Binding String(Button(Interact))), Left, 100, Color(Purple), Color(Purple), Color(
			Purple), Visible To and String, Default Visibility);
		"Ultimate Charger hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 12), Custom String(
			"Ultimate Charger"), Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to rapidly charge your ultimate", Input Binding String(Button(Interact))), Left, 100, Color(Red), Color(Red),
			Color(Red), Visible To and String, Default Visibility);
		"Stun hud text"
		Create HUD Text(Filtered Array(All Living Players(Team 2), Current Array Element.currentPowerUp == 13), Custom String("Stun"),
			Custom String("Hold [{0}] to drop your power up", Input Binding String(Button(Reload))), Custom String(
			"Hold [{0}] to stun nearby enemies", Input Binding String(Button(Interact))), Left, 100, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
	}
}

rule("PLAYER DROPS POWER UP (MANUAL)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Global.gameStatus == True;
		Is Alive(Event Player) == True;
		Is On Ground(Event Player) == True;
		Event Player.currentPowerUp != 0;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Modify Global Variable(powerUpIDs, Append To Array, Event Player.currentPowerUp);
		Modify Global Variable(powerUpPositions, Append To Array, Position Of(Event Player) + Vector(0, 0.250, 0));
		Wait(0.016, Ignore Condition);
		Event Player.currentPowerUp = 0;
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Position Of(Event Player), 25);
	}
}

rule("PLAYER DROPS POWER UP (DEATH)")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.currentPowerUp != 0;
	}

	actions
	{
		While(!Is On Ground(Event Player));
			Wait(0.250, Ignore Condition);
		End;
		Modify Global Variable(powerUpIDs, Append To Array, Event Player.currentPowerUp);
		Modify Global Variable(powerUpPositions, Append To Array, Position Of(Event Player) + Vector(0, 0.250, 0));
		Wait(0.016, Ignore Condition);
		Event Player.currentPowerUp = 0;
		Play Effect(Event Player, Debuff Impact Sound, Color(White), Position Of(Event Player), 25);
	}
}

rule("instantRevive (0-9)")
{
	event
	{
		Subroutine;
		instantRevive;
	}

	actions
	{
		Event Player.interactEntity = First Of(Sorted Array(Filtered Array(All Dead Players(Team 2), Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) <= Global.reviveRadius), Angle Between Vectors(Facing Direction Of(
			Event Player), Direction Towards(Eye Position(Event Player), Position Of(Current Array Element)))));
		Event Player.randVal = Random Integer(1, 100);
		Wait(0.016, Ignore Condition);
		Set Status(Event Player.interactEntity, Null, Invincible, 5);
		Resurrect(Event Player.interactEntity);
		Wait Until(Is Alive(Event Player.interactEntity), 3);
		Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
		If(Event Player.randVal <= 99);
			Small Message(Array(Event Player, Event Player.interactEntity), Custom String("{0} {1}: \"{2}\"", Event Player, Hero Icon String(
				Hero Of(Event Player)), Random Value In Array(Array(Custom String("Get up! We need to move!"), Custom String(
				"I've got you. Now let's move!"), Custom String("We need to go! Get up!")))));
		Else;
			Small Message(Array(Event Player, Event Player.interactEntity), Custom String(
				"{0} {1}: \"On your feet! This is no place to die!\"", Event Player, Hero Icon String(Hero Of(Event Player))));
		End;
	}
}

rule("playerForceField (10-19)")
{
	event
	{
		Subroutine;
		playerForceField;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[10] = Position Of(Event Player);
		If(!Entity Exists(Event Player.powerUpEffects[10]));
			Create Effect(All Players(All Teams), Sphere, Color(Blue), Event Player.powerUpUsePositionsAndInfo[10], 7.500,
				Visible To Position and Radius);
			Event Player.powerUpEffects[10] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Force Field: {0}s", Round To Integer(Event Player.pForceFieldCount1, Up)), Null, Null,
				Right, 0.200, Color(Blue), Color(Blue), Color(Blue), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[11] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Blue), Event Player.powerUpUsePositionsAndInfo[10], 3);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Blue), Event Player.powerUpUsePositionsAndInfo[10], 50);
		"Force field duration"
		For Player Variable(Event Player, pForceFieldCount1, 10, 0, -0.032);
			For Player Variable(Event Player, pForceFieldCount2_bCount1, 0, Number Of Living Players(Team 1), 1);
				If(Distance Between(All Living Players(Team 1)[Event Player.pForceFieldCount2_bCount1],
					Event Player.powerUpUsePositionsAndInfo[10]) <= 7.500);
					Apply Impulse(All Living Players(Team 1)[Event Player.pForceFieldCount2_bCount1], Direction Towards(
						Event Player.powerUpUsePositionsAndInfo[10], Position Of(All Living Players(Team 1)[Event Player.pForceFieldCount2_bCount1])),
						6, To World, Cancel Contrary Motion);
				End;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Destroy Effect(Event Player.powerUpEffects[10]);
		Destroy HUD Text(Event Player.powerUpEffects[11]);
		Event Player.powerUpUsePositionsAndInfo[10] = 0;
	}
}

rule("noCooldowns (20-29)")
{
	event
	{
		Subroutine;
		noCooldowns;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
		Play Effect(Event Player, Good Pickup Effect, Color(Red), Event Player, 50);
		If(Event Player.powerUpEffects[20] == 0);
			Create HUD Text(Event Player, Custom String("No Cooldowns: {0}s", Round To Integer(Event Player.pNoCooldownsCount_bCount2, Up)),
				Null, Null, Right, 0.200, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[20] = Last Text ID;
		End;
		"No cooldown powerup duration"
		For Player Variable(Event Player, pNoCooldownsCount_bCount2, 15, 0, -0.032);
			Set Ability Cooldown(Event Player, Button(Ability 1), 0);
			Set Ability Cooldown(Event Player, Button(Ability 2), 0);
			Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
			Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
			Set Ability Cooldown(Event Player, Button(Interact), 0);
			Set Ability Cooldown(Event Player, Button(Crouch), 0);
			Set Ability Cooldown(Event Player, Button(Jump), 0);
			Set Ability Charge(Event Player, Button(Ability 1), 2);
			Set Ability Charge(Event Player, Button(Ability 2), 2);
			Set Ability Charge(Event Player, Button(Secondary Fire), 2);
			Wait(0.032, Ignore Condition);
		End;
		Destroy HUD Text(Event Player.powerUpEffects[20]);
		Event Player.powerUpEffects[20] = 0;
	}
}

rule("airStrike (30-39)")
{
	event
	{
		Subroutine;
		airStrike;
	}

	actions
	{
		Wait(0.016, Ignore Condition);
		If(Event Player.randVal <= 99);
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"{2}\"", Event Player, Hero Icon String(Hero Of(Event Player)),
				Random Value In Array(Array(Custom String("Air strike incoming!"), Custom String("I'm calling in air support!"), Custom String(
				"I've called in an air strike!")))));
		Else;
			Small Message(All Players(All Teams), Custom String("{0} {1}: \"Tactical nuke, incoming!\"", Event Player, Hero Icon String(
				Hero Of(Event Player))));
		End;
		"Air Strike Location"
		Event Player.powerUpUsePositionsAndInfo[30] = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 40, Null, All Players(All Teams), False);
		Event Player.pAirStrikeCount = 0;
		If(Event Player.powerUpEffects[30] == 0);
			Create Effect(All Players(All Teams), Ring, Color(Red), Event Player.powerUpUsePositionsAndInfo[30], 10,
				Visible To Position and Radius);
			Event Player.powerUpEffects[30] = Last Created Entity;
			Create Effect(All Players(All Teams), Cloud, Color(Red), Event Player.powerUpUsePositionsAndInfo[30], 0.500,
				Visible To Position and Radius);
			Event Player.powerUpEffects[31] = Last Created Entity;
		End;
		Wait(2, Ignore Condition);
		"Count up to max radius. Number of explosions = Max radius / step size"
		For Player Variable(Event Player, pAirStrikeCount, 0, 50, 1);
			"Random position in ring"
			Event Player.powerUpUsePositionsAndInfo[31] = Event Player.powerUpUsePositionsAndInfo[30] + Vector(0, 5, 0)
				+ Direction From Angles(Random Real(0, 360), 0) * Random Real(0, 10);
			"Ray Cast downwards"
			Event Player.powerUpUsePositionsAndInfo[31] = Ray Cast Hit Position(Event Player.powerUpUsePositionsAndInfo[31],
				Event Player.powerUpUsePositionsAndInfo[31] + Vector(0, -25, 0), Null, All Players(All Teams), False);
			Play Effect(All Players(All Teams), Bad Pickup Effect, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 2.500);
			Play Effect(All Players(All Teams), Ring Explosion, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 5);
			Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 100);
			Play Effect(All Players(All Teams), Explosion Sound, Color(Orange), Event Player.powerUpUsePositionsAndInfo[31], 100);
			Event Player.powerUpUsePositionsAndInfo[32] = Filtered Array(All Players(Team 1), Distance Between(Position Of(
				Current Array Element), Event Player.powerUpUsePositionsAndInfo[31]) < 5);
			Damage(Event Player.powerUpUsePositionsAndInfo[32], Event Player, 150);
			Event Player.powerUpUsePositionsAndInfo[32].reviveTimer = 10;
			Wait(0.125, Ignore Condition);
		End;
		Destroy Effect(Event Player.powerUpEffects[30]);
		Destroy Effect(Event Player.powerUpEffects[31]);
		Event Player.powerUpEffects[30] = 0;
	}
}

rule("healBeacon (40-49)")
{
	event
	{
		Subroutine;
		healBeacon;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[40] = Position Of(Event Player);
		If(!Entity Exists(Event Player.powerUpEffects[40]));
			Create Effect(All Players(All Teams), Light Shaft, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, -2, 0),
				0.500, Visible To Position and Radius);
			Event Player.powerUpEffects[40] = Last Created Entity;
			Create Effect(All Players(All Teams), Ring, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40], 10,
				Visible To Position and Radius);
			Event Player.powerUpEffects[41] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Healing Beacon: {0}s", Round To Integer(Event Player.pHealBeaconCount, Up)), Null,
				Null, Right, 0.200, Color(Yellow), Color(Yellow), Color(Yellow), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[42] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40], 10);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Blue), Event Player.powerUpUsePositionsAndInfo[40], 50);
		"Heal Beacon duration"
		For Player Variable(Event Player, pHealBeaconCount, 30, 0, -1);
			Wait(1, Ignore Condition);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 1, 0),
				0.100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 2, 0),
				0.100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 3, 0),
				0.100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40] + Vector(0, 4, 0),
				0.100);
			Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Yellow), Event Player.powerUpUsePositionsAndInfo[40], 40);
			Start Heal Over Time(Players Within Radius(Event Player.powerUpUsePositionsAndInfo[40], 10, Team Of(Event Player), Off),
				Event Player, 2, 30);
		End;
		Destroy Effect(Event Player.powerUpEffects[40]);
		Destroy Effect(Event Player.powerUpEffects[41]);
		Destroy HUD Text(Event Player.powerUpEffects[42]);
		Event Player.powerUpUsePositionsAndInfo[40] = 0;
	}
}

rule("sentryTurret (50-59)")
{
	event
	{
		Subroutine;
		sentryTurret;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[50] = Position Of(Event Player) + Vector(0, 1, 0);
		If(!Entity Exists(Event Player.powerUpEffects[50]));
			Create Effect(All Players(All Teams), Sphere, Color(Orange), Event Player.powerUpUsePositionsAndInfo[50], 0.150,
				Visible To Position and Radius);
			Event Player.powerUpEffects[50] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(0, 60) * 1.500, Color(White),
				Visible To Position and Radius);
			Event Player.powerUpEffects[51] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(120, 60) * 1.500, Color(White),
				Visible To Position and Radius);
			Event Player.powerUpEffects[52] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(240, 60) * 1.500, Color(White),
				Visible To Position and Radius);
			Event Player.powerUpEffects[53] = Last Created Entity;
			Create Beam Effect(All Players(All Teams), Grapple Beam, Event Player.powerUpUsePositionsAndInfo[50],
				Event Player.powerUpUsePositionsAndInfo[50] + (Count Of(Filtered Array(All Living Players(Team 1), Is In Line of Sight(
				Event Player.powerUpUsePositionsAndInfo[50], Current Array Element, Barriers Do Not Block LOS)
				&& !Current Array Element.teleporting)) ? Event Player.powerUpUsePositionsAndInfo[51] * 0.500 : Facing Direction Of(
				Event Player) * 0.500), Color(White), Visible To Position and Radius);
			Event Player.powerUpEffects[54] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Sentry Turret: {0}s", Round To Integer(Event Player.pSentryTurretCount, Up)), Null,
				Null, Right, 0.200, Color(Orange), Color(Orange), Color(Orange), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[55] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Orange), Event Player.powerUpUsePositionsAndInfo[50], 5);
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Blue), Event Player.powerUpUsePositionsAndInfo[50], 50);
		"Sentry Gun Duration"
		For Player Variable(Event Player, pSentryTurretCount, 30, 0, -0.125);
			If(Count Of(Filtered Array(All Living Players(Team 1), Is In Line of Sight(Event Player.powerUpUsePositionsAndInfo[50],
				Current Array Element, Barriers Do Not Block LOS) && !Current Array Element.teleporting)) > 0);
				Event Player.powerUpUsePositionsAndInfo[51] = Direction Towards(Event Player.powerUpUsePositionsAndInfo[50], Position Of(First Of(
					Sorted Array(Filtered Array(All Living Players(Team 1), Is In Line of Sight(Event Player.powerUpUsePositionsAndInfo[50],
					Current Array Element, Barriers Do Not Block LOS)), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(
					Eye Position(Event Player), Eye Position(Current Array Element)))))) + Vector(0, 1, 0));
				Event Player.powerUpUsePositionsAndInfo[52] = Ray Cast Hit Position(Event Player.powerUpUsePositionsAndInfo[50],
					Event Player.powerUpUsePositionsAndInfo[50] + Direction From Angles(Random Real(-1, 1) + Horizontal Angle From Direction(
					Event Player.powerUpUsePositionsAndInfo[51]), Random Real(-1, 1) + Vertical Angle From Direction(
					Event Player.powerUpUsePositionsAndInfo[51])) * 100, All Living Players(Opposite Team Of(Team Of(Event Player))), All Players(
					Team Of(Event Player)), True);
				Play Effect(All Players(All Teams), Ring Explosion Sound, Color(Orange),
					Event Player.powerUpUsePositionsAndInfo[50] + Event Player.powerUpUsePositionsAndInfo[51] * 0.500, 25);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Orange),
					Event Player.powerUpUsePositionsAndInfo[50] + Event Player.powerUpUsePositionsAndInfo[51] * 0.500, 0.100);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Event Player.powerUpUsePositionsAndInfo[52], 0.100);
				Damage(Ray Cast Hit Player(Event Player.powerUpUsePositionsAndInfo[50],
					Event Player.powerUpUsePositionsAndInfo[50] + Direction Towards(Event Player.powerUpUsePositionsAndInfo[50],
					Event Player.powerUpUsePositionsAndInfo[52]) * 100, All Living Players(Opposite Team Of(Team Of(Event Player))), All Players(
					Team Of(Event Player)), True), Event Player, 20);
			End;
			Wait(0.125, Ignore Condition);
		End;
		Destroy Effect(Event Player.powerUpEffects[50]);
		Destroy Effect(Event Player.powerUpEffects[51]);
		Destroy Effect(Event Player.powerUpEffects[52]);
		Destroy Effect(Event Player.powerUpEffects[53]);
		Destroy Effect(Event Player.powerUpEffects[54]);
		Destroy HUD Text(Event Player.powerUpEffects[55]);
		Event Player.powerUpUsePositionsAndInfo[50] = 0;
	}
}

rule("cloakingDevice (60-69)")
{
	event
	{
		Subroutine;
		cloakingDevice;
	}

	actions
	{
		If(Event Player.powerUpEffects[60] == 0);
			Event Player.movementSpeed *= 1.500;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			Create Effect(All Players(All Teams), Sphere, Color(Blue), Event Player, Distance Between(Eye Position(Event Player), Position Of(
				Event Player)) * 0.950, Visible To Position and Radius);
			Event Player.powerUpEffects[60] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Cloaking Device: {0}s", Round To Integer(Event Player.pCloakingDeviceCount, Up)),
				Null, Event Player.pCloakingDeviceCount < 23 ? Custom String("Cancel (Press [{0}] + [{1}])", Input Binding String(Button(
				Crouch)), Input Binding String(Button(Interact))) : Custom String(""), Right, 0.200, Color(Blue), Color(Blue), Color(Blue),
				Visible To and String, Default Visibility);
			Event Player.powerUpEffects[61] = Last Text ID;
		End;
		If(!Event Player.invisible);
			Small Message(Event Player, Custom String("Cloaking activated. You are now invisible."));
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Blue), Position Of(Event Player), Distance Between(Eye Position(
			Event Player), Position Of(Event Player)) * 0.950);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Blue), Position Of(Event Player), 50);
		"Cloaking Duration"
		For Player Variable(Event Player, pCloakingDeviceCount, 25, 0, -0.032);
			Event Player.invisible = True;
			If(Event Player.pCloakingDeviceCount < 23 && Is Button Held(Event Player, Button(Crouch)) && Is Button Held(Event Player, Button(
				Interact)));
				Small Message(Event Player, Custom String("Cloaking deactivated"));
				Break;
			End;
			If(Is Dead(Event Player));
				Break;
			End;
			Wait(0.032, Ignore Condition);
		End;
		Event Player.invisible = False;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.powerUpEffects[60]);
		Destroy HUD Text(Event Player.powerUpEffects[61]);
		Event Player.powerUpEffects[60] = 0;
		If(!Event Player.invisible);
			Small Message(Event Player, Custom String("You are now visible"));
		End;
		Event Player.movementSpeed /= 1.500;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
	}
}

rule("superNano (70-79)")
{
	event
	{
		Subroutine;
		superNano;
	}

	actions
	{
		If(Event Player.powerUpEffects[70] == 0);
			Event Player.movementSpeed *= 1.500;
			Set Move Speed(Event Player, Event Player.movementSpeed * 100);
			Create Effect(All Players(All Teams), Good Aura, Color(Red), Event Player, Distance Between(Eye Position(Event Player),
				Position Of(Event Player)) * 0.950, Visible To Position and Radius);
			Event Player.powerUpEffects[70] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Super Nano: {0}s", Round To Integer(Event Player.pSuperNanoCount, Up)), Null, Null,
				Right, 0.200, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[71] = Last Text ID;
			Create Effect(All Players(All Teams), Bad Aura, Color(Red), Event Player, 0.500, Visible To Position and Radius);
			Event Player.powerUpEffects[72] = Last Created Entity;
			Start Damage Modification(All Players(Team 1), Event Player, 200, Receivers Damagers and Damage Percent);
			Event Player.powerUpEffects[73] = Last Damage Modification ID;
			Start Damage Modification(Event Player, All Players(All Teams), 50, Receivers Damagers and Damage Percent);
			Event Player.powerUpEffects[74] = Last Damage Modification ID;
		End;
		Heal(Event Player, Null, 100);
		Set Damage Received(Event Player, 50);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Position Of(Event Player), Distance Between(Eye Position(
			Event Player), Position Of(Event Player)) * 0.950);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Red), Position Of(Event Player), 50);
		For Player Variable(Event Player, pSuperNanoCount, 20, 0, -1);
			If(Is Dead(Event Player));
				Break;
			End;
			Wait(1, Ignore Condition);
		End;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.powerUpEffects[70]);
		Destroy HUD Text(Event Player.powerUpEffects[71]);
		Destroy Effect(Event Player.powerUpEffects[72]);
		Stop Damage Modification(Event Player.powerUpEffects[73]);
		Stop Damage Modification(Event Player.powerUpEffects[74]);
		Set Move Speed(Event Player, 100);
		Set Damage Received(Event Player, 100);
		Event Player.powerUpEffects[70] = 0;
		Event Player.movementSpeed /= 1.500;
		Set Move Speed(Event Player, Event Player.movementSpeed * 100);
	}
}

rule("bouncePad (80-89)")
{
	event
	{
		Subroutine;
		bouncePad;
	}

	actions
	{
		Event Player.powerUpUsePositionsAndInfo[80] = Position Of(Event Player);
		If(Event Player.powerUpEffects[80] == 0);
			Create Effect(All Players(All Teams), Ring, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80], 2,
				Visible To Position and Radius);
			Event Player.powerUpEffects[80] = Last Created Entity;
			Create HUD Text(Event Player, Custom String("Bounce Pad: {0}s", Round To Integer(Event Player.pBouncePadCount1, Up)), Null, Null,
				Right, 0.200, Color(Purple), Color(Purple), Color(Purple), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[81] = Last Text ID;
		End;
		Play Effect(All Players(All Teams), Good Explosion, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80], 2);
		Play Effect(All Players(All Teams), Buff Explosion Sound, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80], 50);
		Wait(1, Ignore Condition);
		"Bounce pad duration"
		For Player Variable(Event Player, pBouncePadCount1, 60, 0, -0.125);
			If(Event Player.pBouncePadCount1 % 0.250 == 0);
				Play Effect(All Players(All Teams), Ring Explosion, Color(Purple), Event Player.powerUpUsePositionsAndInfo[80] + Vector(0, 0.125,
					0), 4);
			End;
			"Determine which players are on the bounce pad"
			Event Player.powerUpUsePositionsAndInfo[81] = Filtered Array(All Living Players(Team 2), Distance Between(
				Event Player.powerUpUsePositionsAndInfo[80], Position Of(Current Array Element)) < 2 && Is On Ground(Current Array Element));
			If(Count Of(Event Player.powerUpUsePositionsAndInfo[81]) > 0);
				"For each bouncer"
				For Player Variable(Event Player, pBouncePadCount2, 0, Count Of(Event Player.powerUpUsePositionsAndInfo[81]), 1);
					"Current bouncer"
					Event Player.bouncePadBouncer = Event Player.powerUpUsePositionsAndInfo[81][Event Player.pBouncePadCount2];
					Apply Impulse(Event Player.bouncePadBouncer, Vector(0, 1, 0), 22, To World, Cancel Contrary Motion);
				End;
				Play Effect(Event Player.powerUpUsePositionsAndInfo[81], Ring Explosion Sound, Color(White),
					Event Player.powerUpUsePositionsAndInfo[80], 50);
			End;
			Wait(0.125, Ignore Condition);
		End;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.powerUpEffects[80]);
		Destroy HUD Text(Event Player.powerUpEffects[81]);
		Event Player.powerUpEffects[80] = 0;
	}
}

rule("ultimateCharger (90-99)")
{
	event
	{
		Subroutine;
		ultimateCharger;
	}

	actions
	{
		If(Event Player.powerUpEffects[90] == 0);
			Create HUD Text(Event Player, Custom String("Ultimate Charger: {0}s", Round To Integer(Event Player.pUltimateChargerCount, Up)),
				Null, Null, Right, 0.200, Color(Red), Color(Red), Color(Red), Visible To and String, Default Visibility);
			Event Player.powerUpEffects[90] = Last Text ID;
		End;
		Play Effect(Event Player, Buff Explosion Sound, Color(Red), Position Of(Event Player), 50);
		"Bounce pad duration"
		For Player Variable(Event Player, pUltimateChargerCount, 20, 0, -0.125);
			Wait Until(!Is Using Ultimate(Event Player), 9999);
			Set Ultimate Charge(Event Player, Ultimate Charge Percent(Event Player) + 2);
			Wait(0.125, Ignore Condition);
		End;
		Wait(0.250, Ignore Condition);
		Destroy HUD Text(Event Player.powerUpEffects[90]);
		Event Player.powerUpEffects[90] = 0;
	}
}

rule("stun (100-109)")
{
	event
	{
		Subroutine;
		stun;
	}

	actions
	{
		If(Event Player.powerUpEffects[100] == 0);
			"Stun beam effect"
			Create Beam Effect(All Players(All Teams), Bad Beam, Event Player.pStunChase1, Event Player.pStunChase1 + Direction Towards(
				Event Player.pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[100]) + Vector(0, Global.losHeightCheck, 0))
				* Min(3, Distance Between(Event Player.pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[100]) + Vector(0,
				Global.losHeightCheck, 0))), Color(Sky Blue), Visible To Position and Radius);
			Event Player.powerUpEffects[100] = Last Created Entity;
		End;
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Position Of(Event Player), 30);
		"Stun beam lead"
		Event Player.pStunChase1 = Position Of(Event Player) + Vector(0, Global.losHeightCheck, 0);
		"Stun origin player"
		Event Player.powerUpUsePositionsAndInfo[100] = Event Player;
		"Stun Target"
		Event Player.powerUpUsePositionsAndInfo[101] = First Of(Sorted Array(Filtered Array(All Living Players(Opposite Team Of(Team Of(
			Event Player))), Distance Between(Position Of(Event Player), Position Of(Current Array Element)) < 15 * Event Player.size),
			Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
			Current Array Element)))));
		Chase Player Variable At Rate(Event Player, pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[101]) + Vector(0,
			Global.losHeightCheck, 0), 50, Destination and Rate);
		"Number of bounces"
		For Player Variable(Event Player, pStunCount, 0, 50, 1);
			If(Event Player.powerUpUsePositionsAndInfo[101] == Null);
				Break;
			End;
			Wait Until(Distance Between(Event Player.pStunChase1, Position Of(Event Player.powerUpUsePositionsAndInfo[101]) + Vector(0,
				Global.losHeightCheck, 0)) < 0.100, 3);
			Set Status(Event Player.powerUpUsePositionsAndInfo[101], Event Player, Stunned, Array Contains(Global.bosses,
				Event Player.powerUpUsePositionsAndInfo[101]) ? 0.500 : 1);
			Play Effect(All Players(All Teams), Bad Explosion, Color(White), Event Player.powerUpUsePositionsAndInfo[101], 0.500);
			Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Position Of(Event Player.powerUpUsePositionsAndInfo[101]),
				50);
			Wait(0.016, Ignore Condition);
			"Previous target is new origin"
			Event Player.powerUpUsePositionsAndInfo[100] = Event Player.powerUpUsePositionsAndInfo[101];
			"Set next target"
			Event Player.powerUpUsePositionsAndInfo[101] = Random Value In Array(Remove From Array(Filtered Array(All Living Players(Team 1),
				Distance Between(Position Of(Event Player.powerUpUsePositionsAndInfo[100]), Position Of(Current Array Element))
				< 15 && !Current Array Element.teleporting), Event Player.powerUpUsePositionsAndInfo[101]));
		End;
		Stop Chasing Player Variable(Event Player, pStunChase1);
		Destroy Effect(Event Player.powerUpEffects[100]);
		Event Player.powerUpEffects[100] = 0;
	}
}

rule("powerUpAssignment")
{
	event
	{
		Subroutine;
		powerUpAssignment;
	}

	actions
	{
		"Cure"
		If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 1);
			Create Effect(All Players(All Teams), Orb, Color(Green), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("CURE"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Instant Revive"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 2);
			Create Effect(All Players(All Teams), Orb, Color(Yellow), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Revive"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Force Field"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 3);
			Create Effect(All Players(All Teams), Orb, Color(Blue), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Force Field"), Global.powerUpPositions[Count Of(Global.powerUpText)],
				1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"No Cooldowns"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 4);
			Create Effect(All Players(All Teams), Orb, Color(Red), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("No Cooldowns"), Global.powerUpPositions[Count Of(Global.powerUpText)],
				1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Air Strike"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 5);
			Create Effect(All Players(All Teams), Orb, Color(Orange), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Air Strike"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Healing Beacon"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 6);
			Create Effect(All Players(All Teams), Orb, Color(Yellow), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Healing Beacon"), Global.powerUpPositions[Count Of(Global.powerUpText)
				], 1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Vaccine"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 7);
			Create Effect(All Players(All Teams), Orb, Color(Green), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Vaccine"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Sentry Turret"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 8);
			Create Effect(All Players(All Teams), Orb, Color(Orange), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Sentry Turret"), Global.powerUpPositions[Count Of(Global.powerUpText)],
				1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Cloaking Device"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 9);
			Create Effect(All Players(All Teams), Orb, Color(Blue), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Cloaking Device"), Global.powerUpPositions[Count Of(Global.powerUpText)
				], 1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Super Nano"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 10);
			Create Effect(All Players(All Teams), Orb, Color(Red), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Super Nano"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Bounce pad"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 11);
			Create Effect(All Players(All Teams), Orb, Color(Purple), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Bounce Pad"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Ultimate Charger"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 12);
			Create Effect(All Players(All Teams), Orb, Color(Red), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Ultimate Charger"), Global.powerUpPositions[Count Of(
				Global.powerUpText)], 1, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		"Stun"
		Else If(Global.powerUpIDs[Count Of(Global.powerUpEffect)] == 13);
			Create Effect(All Players(All Teams), Orb, Color(White), Global.powerUpPositions[Count Of(Global.powerUpEffect)], 1, Visible To);
			Create In-World Text(All Players(All Teams), Custom String("Stun"), Global.powerUpPositions[Count Of(Global.powerUpText)], 1,
				Clip Against Surfaces, Visible To, Color(White), Default Visibility);
		End;
	}
}

rule("powerUpUsage")
{
	event
	{
		Subroutine;
		powerUpUsage;
	}

	actions
	{
		"Cure"
		If(Event Player.currentPowerUp == 1);
			Play Effect(All Players(All Teams), Good Pickup Effect, Color(Green), Event Player, 1);
			If(Event Player.infectionLvl > 0);
				Event Player.infected = False;
				Event Player.infectionLvl = 0;
			End;
			Stop All Damage Over Time(Event Player);
			Clear Status(Event Player, Burning);
			Start Heal Over Time(Event Player, Event Player, 5, 20);
			Small Message(Event Player, Custom String("You are cured!"));
			Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
		"Instant Revive"
		Else If(Event Player.currentPowerUp == 2);
			Abort If(Count Of(Filtered Array(All Dead Players(Team 2), Distance Between(Position Of(Event Player), Position Of(
				Current Array Element)) <= Global.reviveRadius)) == 0);
			Start Rule(instantRevive, Restart Rule);
		"Force Field"
		Else If(Event Player.currentPowerUp == 3);
			Start Rule(playerForceField, Restart Rule);
		"No Cooldowns"
		Else If(Event Player.currentPowerUp == 4);
			Start Rule(noCooldowns, Restart Rule);
		"Air Strike"
		Else If(Event Player.currentPowerUp == 5);
			If(Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 41, Null, All Players(All Teams), False)) > 40);
				Small Message(Event Player, Custom String("Aim at a surface to call in an aistrike"));
				Abort;
			End;
			Start Rule(airStrike, Restart Rule);
		"Healing Beacon"
		Else If(Event Player.currentPowerUp == 6);
			Start Rule(healBeacon, Restart Rule);
		"Vaccine"
		Else If(Event Player.currentPowerUp == 7);
			If(Event Player.infected);
				Small Message(Event Player, Custom String("You cannot vaccinate yourself while your are infected"));
				Abort;
			Else;
				Play Effect(All Players(All Teams), Good Pickup Effect, Color(Green), Event Player, 1);
				Play Effect(Event Player, Buff Explosion Sound, Color(Aqua), Position Of(Event Player), 50);
				Small Message(Event Player, Custom String("You have been vaccinated!"));
				Event Player.infectionLvl -= 1;
			End;
		"Sentry Turret"
		Else If(Event Player.currentPowerUp == 8);
			If(!Is On Ground(Event Player));
				Small Message(Event Player, Custom String("You must be on the ground to place a sentry turret"));
				Abort;
			Else;
				Start Rule(sentryTurret, Restart Rule);
			End;
		"Cloaking Device"
		Else If(Event Player.currentPowerUp == 9);
			Start Rule(cloakingDevice, Restart Rule);
		"Super Nano"
		Else If(Event Player.currentPowerUp == 10);
			Start Rule(superNano, Restart Rule);
		"Bounce Pad"
		Else If(Event Player.currentPowerUp == 11);
			If(Is On Ground(Event Player));
				Start Rule(bouncePad, Restart Rule);
			Else;
				Small Message(Event Player, Custom String("You must be on the ground to place a bounce pad"));
				Abort;
			End;
		"Ultimate Charger"
		Else If(Event Player.currentPowerUp == 12);
			Start Rule(ultimateCharger, Restart Rule);
		"Stun"
		Else If(Event Player.currentPowerUp == 13);
			"Check if their are targets nearby and in view angle"
			If(Is True For Any(All Living Players(Opposite Team Of(Team Of(Event Player))), Distance Between(Position Of(Event Player),
				Position Of(Current Array Element)) < 15 * Event Player.size && Angle Between Vectors(Facing Direction Of(Event Player),
				Direction Towards(Eye Position(Event Player), Eye Position(Current Array Element))) < 45));
				Start Rule(stun, Restart Rule);
			Else;
				Small Message(Event Player, Custom String("Aim at a nearby target"));
				Abort;
			End;
		End;
		Event Player.currentPowerUp = 0;
	}
}

rule("enablePowerups")
{
	event
	{
		Subroutine;
		enablePowerups;
	}

	actions
	{
		Global.availablePowerups[0] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Cure"), True, 0) ? 1 : -1;
		Global.availablePowerups[1] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Revive"), True, 1) ? 2 : -1;
		Global.availablePowerups[2] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Force Field"), True, 2) ? 3 : -1;
		Global.availablePowerups[3] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("No Cooldowns"), True, 3) ? 4 : -1;
		Global.availablePowerups[4] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Airstrike"), True, 4) ? 5 : -1;
		Global.availablePowerups[5] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Healing Beacon"), True, 5)
			? 6 : -1;
		Global.availablePowerups[6] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Vaccine"), True, 6) ? 7 : -1;
		Global.availablePowerups[7] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Sentry Turret"), True, 7)
			? 8 : -1;
		Global.availablePowerups[8] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Cloaking Device"), True, 8)
			? 9 : -1;
		Global.availablePowerups[9] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Super Nano"), True, 9) ? 10 : -1;
		Global.availablePowerups[10] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Bounce Pad"), True, 10)
			? 11 : -1;
		Global.availablePowerups[11] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Ultimate Charger"), True, 11)
			? 12 : -1;
		Global.availablePowerups[12] = Workshop Setting Toggle(Custom String("Power Ups"), Custom String("Stun"), True, 12) ? 13 : -1;
		Modify Global Variable(availablePowerups, Remove From Array By Value, -1);
	}
}

disabled rule("============================================== ENHANCEMENTS ====================================================")
{
	event
	{
		Ongoing - Global;
	}
}

rule("PLAYER ENHANCEMENT INITIALIZATION")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Global.gameStatus == True;
		Is Dummy Bot(Event Player) != True;
	}

	actions
	{
		If(Event Player.enhancementValues[0] == 0);
			"Default Enhancement: Workshop Setting"
			Event Player.enhancementValues[0] = Workshop Setting Combo(Custom String("Enhancements"), Custom String("Default Enhancement"), 9,
				Array(Custom String("No Enhancement"), Custom String("Infection Resistance"), Custom String("Scavenger"), Custom String(
				"Laser Barricade"), Custom String("Brain Killer"), Custom String("Pyrotechnic"), Custom String("Plague Doctor"), Custom String(
				"Born to Battle"), Custom String("Kevlar"), Custom String("Nano Nurse"), Custom String("Hitchhiker"), Custom String("P.U.P.")),
				0);
		End;
		"Infection Resistance"
		If(Event Player.enhancementValues[0] == 1);
			"Enhancement: Infection Resistance"
			Create HUD Text(Event Player, Custom String("Infection Resistance {0}", Icon String(Poison 2)), Null,
				Event Player.infectionLvl >= 1 ? Custom String("{0}s", Round To Integer((Event Player.infectionLvl - Round To Integer(
				Event Player.infectionLvl, Down)) * 20, Up)) : Custom String(""), Left, 99, Color(Green), Color(Green), Color(Green), String,
				Default Visibility);
			Chase Player Variable At Rate(Event Player, infectionLvl, 0, Event Player.infectionLvl >= 1 ? 0.050 : (
				Event Player.infectionLvl >= 0 ? 0.033 : 0), Destination and Rate);
		"Scavenger"
		Else If(Event Player.enhancementValues[0] == 2);
			"Enhancement: Scavenger"
			Create HUD Text(Event Player, Custom String("Scavenger {0}", Ability Icon String(Hero Of(Event Player), Button(Primary Fire))),
				Null, Null, Left, 99, Color(Gray), Color(Gray), Color(Gray), String, Default Visibility);
			Event Player.enhancementChase1 = 0;
			"Ammo visual effect"
			Create Effect(Filtered Array(Event Player, Event Player.enhancementChase1 != 0), Good Aura, Color(Turquoise),
				Event Player.enhancementChase1, 0.100, Visible To Position and Radius);
			"Ammo amount"
			Create In-World Text(Filtered Array(Event Player, Event Player.enhancementChase1 != 0), Custom String("{0} Ammo", Round To Integer(
				Max Ammo(Event Player, Is In Alternate Form(Event Player) && Max Ammo(Event Player, 1) > 0 ? 1 : 0) / 3, Up)),
				Event Player.enhancementChase1, 1, Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
		"Laser Barricade"
		Else If(Event Player.enhancementValues[0] == 3);
			"Enhancement: Laser Barricade"
			Create HUD Text(Event Player, Custom String("Laser Barricade {0}{1}", Ability Icon String(Hero(Reinhardt), Button(Secondary Fire)),
				Event Player.enhancementValues[3] > 0 ? Custom String(" {0}s", Event Player.enhancementValues[3]) : Custom String("")),
				Event Player.enhancementChase1 > 0 ? Custom String(" {0}HP", Round To Integer(Event Player.enhancementChase1, Up))
				: Custom String(""), Event Player.enhancementValues[3] <= 0 ? Custom String("Hold [{0}] to place a barricade",
				Input Binding String(Button(Melee))) : Custom String(""), Left, 99, Event Player.enhancementValues[3] > 0 ? Color(Red) : Color(
				Blue), Color(Blue), Color(Blue), Visible To String and Color, Default Visibility);
			"Barricade placement visual"
			Create Beam Effect(Filtered Array(Event Player, Is Button Held(Event Player, Button(Melee))
				&& Event Player.enhancementValues[3] <= 0 && Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(
				Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 31, Null, Null, False)) <= 30), Bad Beam,
				World Vector Of(Vector(-0.500 * Event Player.enhancementValues[2], 0.100, 0), Event Player, Rotation) + Ray Cast Hit Position(
				Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 30, Null, All Players(All Teams),
				False), World Vector Of(Vector(0.500 * Event Player.enhancementValues[2], 0.100, 0), Event Player, Rotation)
				+ Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 30, Null,
				All Players(All Teams), False), Color(Green), Visible To Position and Radius);
			"Barricade bottom"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementValues[4] != Null), Bad Beam,
				Event Player.enhancementValues[5], Event Player.enhancementValues[6], Color(Blue), Visible To Position and Radius);
			"Barricade side 1"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementChase1 > 0), Bad Beam,
				Event Player.enhancementValues[5] + Vector(0, Event Player.enhancementValues[1], 0), Event Player.enhancementValues[5], Color(
				Blue), Visible To Position and Radius);
			"Barricade side 2"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementChase1 > 0), Bad Beam,
				Event Player.enhancementValues[6], Event Player.enhancementValues[6] + Vector(0, Event Player.enhancementValues[1], 0), Color(
				Blue), Visible To Position and Radius);
			"Barricade top"
			Create Beam Effect(Filtered Array(All Players(All Teams), Event Player.enhancementChase1 > 0), Bad Beam,
				Event Player.enhancementValues[6] + Vector(0, Event Player.enhancementValues[1], 0),
				Event Player.enhancementValues[5] + Vector(0, Event Player.enhancementValues[1], 0), Color(Blue),
				Visible To Position and Radius);
			"Barricade health"
			Create In-World Text(Event Player.enhancementChase1 > 0 ? All Players(All Teams) : Null, Custom String("{0}HP", Round To Integer(
				Event Player.enhancementChase1, Up)), Event Player.enhancementValues[4] + Vector(0, 1, 0), 1.500, Clip Against Surfaces,
				Visible To Position and String, Color(Blue), Default Visibility);
			"Barrier height"
			Event Player.enhancementValues[1] = 2;
			"Barrier width"
			Event Player.enhancementValues[2] = 5;
		"Brain Killer"
		Else If(Event Player.enhancementValues[0] == 4);
			"Enhancement: Brain Killer"
			Create HUD Text(Event Player, Custom String("Brain Killer {0}", Icon String(Skull)), Null, Null, Left, 99, Color(Red), Color(Red),
				Color(Red), String, Default Visibility);
		"Pyrotechnic"
		Else If(Event Player.enhancementValues[0] == 5);
			"Enhancement: Pyrotechnic"
			Create HUD Text(Event Player, Custom String("Pyrotechnic {0}", Icon String(Fire)), Null, Null, Left, 99,
				Event Player.enhancementValues[1] ? Color(Orange) : Color(Red), Color(Orange), Color(Orange), String and Color,
				Default Visibility);
			"Pyro Active"
			Event Player.enhancementValues[1] = True;
			"Special enhancement color"
			Event Player.enhancementValues[2] = Custom Color(252, 78, 3, 255);
			"Fire Fuel"
			Event Player.enhancementChase1 = 100;
			Event Player.enhancementChase2 = Empty Array;
		"Plague Doctor"
		Else If(Event Player.enhancementValues[0] == 6);
			"Enhancement: Plague Doctor"
			Create HUD Text(Event Player, Custom String("Plague Doctor {0}", Icon String(Plus)), Null, Custom String(
				"Infection Reduced: {0} lvls", Event Player.enhancementValues[1]), Left, 99, Color(Green), Color(Green), Color(Green), String,
				Default Visibility);
			"Plague doctor does 100 + x% more healing to infected players"
			Start Healing Modification(Filtered Array(All Players(Team 2), Current Array Element.infected), Event Player, 150,
				Receivers and Healers);
			Event Player.enhancementValues[1] = 0;
		"Born to Battle"
		Else If(Event Player.enhancementValues[0] == 7);
			"Enhancement: Born to Battle"
			Create HUD Text(Event Player, Custom String("Born to Battle {0}", Icon String(Bolt)), Null,
				Event Player.enhancementValues[1] ? Icon String(Checkmark) : Custom String(""), Left, 99, Color(Gray), Color(Gray), Color(
				Gray), String, Default Visibility);
			Event Player.enhancementValues[1] = False;
		"Kevlar"
		Else If(Event Player.enhancementValues[0] == 8);
			"Enhancement Selection: Kevlar"
			Create HUD Text(Event Player, Custom String("Kevlar {0}", Icon String(Stop)), Null, Null, Left, 99, Custom Color(240, 129, 26,
				255), Color(Sky Blue), Color(Sky Blue), String, Default Visibility);
			Wait Until(Event Player.initialMaxHealth != 0, 99999);
			Add Health Pool To Player(Event Player, Armor, 75, True, False);
			Event Player.enhancementValues[1] = Last Created Health Pool;
		"Nano Nurse"
		Else If(Event Player.enhancementValues[0] == 9);
			"Enhancement Selection: Nano Nurse"
			Create HUD Text(Event Player, Custom String("Nano Nurse {0}", Icon String(Plus)), Null, Normalized Health(Event Player)
				< 1 && Event Player.enhancementValues[2] ? Custom String("Regenerating Health") : Custom String(""), Left, 99, Color(Yellow),
				Color(Yellow), Color(Yellow), String, Default Visibility);
			"Healing effect"
			Create Effect(Filtered Array(Event Player, Normalized Health(Event Player) < 1 && Event Player.enhancementValues[2]), Sparkles,
				Color(Yellow), Event Player, Evaluate Once(Distance Between(Position Of(Event Player), Eye Position(Event Player)) * 0.950)
				* Event Player.size, Visible To Position and Radius);
			Event Player.enhancementValues[1] = 0;
			Event Player.enhancementValues[2] = False;
		"Hitchhiker"
		Else If(Event Player.enhancementValues[0] == 10);
			"Enhancement Selection: Hitchhiker"
			Create HUD Text(Event Player, Custom String("Hitchhiker {0}", Ability Icon String(Hero(Zenyatta), Button(Ultimate))), Null,
				Event Player.attached ? Custom String("Press [{0}] to dismount", Input Binding String(Button(Crouch))) : (Is True For Any(
				Remove From Array(Global.playerTargetList, Event Player), !Current Array Element.attached && Distance Between(Position Of(
				Event Player), Position Of(Current Array Element)) < 2 * Current Array Element.size) ? Custom String("Press [{0}] to attach",
				Input Binding String(Button(Crouch))) : Custom String("")), Left, 99, Color(Purple), Color(Purple),
				Event Player.attached ? Color(Red) : Color(Purple), Visible To String and Color, Default Visibility);
			Event Player.enhancementValues[1] = 0;
			Event Player.enhancementValues[2] = 0;
			Start Assist(Event Player.enhancementValues[1], Event Player, Assisters and Targets);
		"P.U.P."
		Else If(Event Player.enhancementValues[0] == 11);
			"Enhancement Selection: P.U.P."
			Create HUD Text(Event Player, Custom String("P.U.P. {0}", Icon String(Happy)), Null, Null, Left, 99,
				Event Player.enhancementValues[1] == Color(Sky Blue) && Event Player.enhancementChase2 > 0 ? Color(Blue)
				: Event Player.enhancementValues[1], Color(Blue), Color(Blue), Visible To String and Color, Default Visibility);
			"Postion of P.U.P."
			Event Player.enhancementChase1 = Position Of(Event Player) + Vector(0, 200, 0);
			"P.U.P. Default movment"
			Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player) + Direction Towards(Eye Position(
				Event Player), Event Player.enhancementChase1), Absolute Value(Distance Between(Eye Position(Event Player),
				Event Player.enhancementChase1) - 1), Destination and Rate);
			Event Player.enhancementChase2 = 0;
			"P.U.P. ability cooldown"
			Chase Player Variable At Rate(Event Player, enhancementChase2, 0, Event Player.enhancementValues[2] ? 0 : 1, Destination and Rate);
			"P.U.P. visual"
			Create Effect(All Players(All Teams), Sphere, Event Player.enhancementValues[1], Event Player.enhancementChase1, 0.250,
				Visible To Position Radius and Color);
			"P.U.P. Beam"
			Create Beam Effect(Filtered Array(All Players(All Teams),
				Event Player.enhancementValues[2] && Event Player.enhancementValues[3] != Null), Good Beam, Event Player.enhancementChase1,
				Event Player.enhancementValues[3], Event Player.enhancementValues[1], Visible To Position Radius and Color);
			"P.U.P using beam sound"
			Create Effect(Filtered Array(All Players(All Teams), Event Player.enhancementValues[2]), Beacon Sound, Color(Sky Blue),
				Event Player.enhancementChase1, 200, Visible To Position and Radius);
			"Freeze aura"
			Create Effect(Filtered Array(All Players(All Teams), Event Player.enhancementValues[4]), Bad Aura, Color(Sky Blue),
				Event Player.enhancementValues[3], Event Player.enhancementValues[3].size, Visible To Position and Radius);
			"Default color"
			Event Player.enhancementValues[1] = Color(Sky Blue);
			"Beam visibility"
			Event Player.enhancementValues[2] = False;
			"P.U.P. target null"
			Event Player.enhancementValues[3] = Null;
			"Freeze aura visibility"
			Event Player.enhancementValues[4] = False;
	}
}

rule("SCAVENGER REPLENISHES AMMO")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 2;
	}

	actions
	{
		Modify Player Variable(Event Player, enhancementValues, Append To Array, Position Of(Victim));
		Start Rule(scavengerManagement, Do Nothing);
	}
}

rule("scavengerManagement")
{
	event
	{
		Subroutine;
		scavengerManagement;
	}

	actions
	{
		While(Event Player.enhancementValues[1] != Null);
			Event Player.enhancementChase1 = Event Player.enhancementValues[1];
			Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player) + Vector(0, -0.500, 0),
				Event Player.enhancementChase1 != 0 ? 20 : 0, Destination and Rate);
			Wait Until(Distance Between(Event Player.enhancementChase1, Eye Position(Event Player) + Vector(0, -0.500, 0)) < 0.100, 99999);
			Stop Chasing Player Variable(Event Player, enhancementChase1);
			Event Player.enhancementChase1 = 0;
			Play Effect(Event Player, Buff Explosion Sound, Color(White), Event Player, 50);
			"Prevent ammo collection during reload animation"
			If(Is Reloading(Event Player));
				Wait Until(!Is Reloading(Event Player), 3);
				Set Ammo(Event Player, 0, Ammo(Event Player, 0) + Round To Integer(Max Ammo(Event Player, 0) / 3, Up));
				Set Ammo(Event Player, 1, Ammo(Event Player, 1) + Round To Integer(Max Ammo(Event Player, 1) / 3, Up));
			Else;
				If(Ammo(Event Player, 0) < Max Ammo(Event Player, 0));
					Set Ammo(Event Player, 0, Min(Ammo(Event Player, 0) + Round To Integer(Max Ammo(Event Player, 0) / 3, Up), Max Ammo(Event Player,
						0)));
				End;
				If(Ammo(Event Player, 1) < Max Ammo(Event Player, 1));
					Set Ammo(Event Player, 1, Min(Ammo(Event Player, 1) + Round To Integer(Max Ammo(Event Player, 1) / 3, Up), Max Ammo(Event Player,
						1)));
				End;
			End;
			Modify Player Variable(Event Player, enhancementValues, Remove From Array By Index, 1);
		End;
	}
}

rule("LASER BARRICADE (PLACEMENT)")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.gameStatus == True;
		Event Player.enhancementValues[0] == 3;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Alive(Event Player) == True;
		Event Player.enhancementValues[3] <= 0;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Play Effect(Event Player, Good Explosion, Color(Blue), Eye Position(Event Player) + Direction From Angles(
			Horizontal Facing Angle Of(Event Player) + Random Real(-5, 5), Vertical Facing Angle Of(Event Player) + Random Real(-5, 5))
			* 1.500, 0.100);
		Play Effect(Event Player, Buff Explosion Sound, Color(Blue), Position Of(Event Player), 75);
		Wait Until(!Is Button Held(Event Player, Button(Melee)) || Is Dead(Event Player), 9999);
		Abort If(Distance Between(Eye Position(Event Player), Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 31, Null, Null, False)) > 30);
		Abort If(Is Dead(Event Player));
		"Laser Barrier health"
		Event Player.enhancementChase1 = 10000;
		"Barrier center point"
		Event Player.enhancementValues[4] = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 30, Null, All Players(All Teams), False);
		"Barrier corner 1"
		Event Player.enhancementValues[5] = Event Player.enhancementValues[4] + World Vector Of(Vector(
			-0.500 * Event Player.enhancementValues[2], 0, 0), Event Player, Rotation);
		"Barrier Corner 2"
		Event Player.enhancementValues[6] = Event Player.enhancementValues[4] + World Vector Of(Vector(
			0.500 * Event Player.enhancementValues[2], 0, 0), Event Player, Rotation);
		"Reference point 1"
		Event Player.enhancementValues[7] = Event Player.enhancementValues[4] + Direction From Angles(Horizontal Facing Angle Of(
			Event Player), 0);
		"Reference point 2"
		Event Player.enhancementValues[8] = Event Player.enhancementValues[4] + Direction From Angles(Horizontal Facing Angle Of(
			Event Player), 0) * -1;
		"Reference direction"
		Event Player.enhancementValues[9] = Direction Towards(Event Player.enhancementValues[5], Event Player.enhancementValues[6]);
		Play Effect(Event Player, Ring Explosion, Color(Blue), Event Player.enhancementValues[4], 2);
		Play Effect(Event Player, Buff Explosion Sound, Color(Blue), Event Player.enhancementValues[4], 50);
		Small Message(Event Player, Custom String("Barricade placed!"));
		"Laser Barrier cooldown"
		Event Player.enhancementValues[3] = 30;
		While(Event Player.enhancementValues[3] > 0);
			Wait(1, Ignore Condition);
			Event Player.enhancementValues[3] += -1;
		End;
	}
}

rule("LASER BARRICADE BLOCKS ZOMBIES")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 3;
		"Barrier health is greater than 0"
		Event Player.enhancementChase1 > 0;
		"Horizontal distance check"
		Is True For Any(All Living Players(Team 1), Distance Between(Event Player.enhancementValues[4], Vector(X Component Of(Position Of(
			Current Array Element)), Y Component Of(Position Of(Event Player.enhancementValues[4])), Z Component Of(Position Of(
			Current Array Element)))) < 0.500 * Event Player.enhancementValues[2]) == True;
		"If feet are below highest point of wall"
		Is True For Any(All Living Players(Team 1), Y Component Of(Position Of(Current Array Element)) < Y Component Of(
			Event Player.enhancementValues[4]) + Event Player.enhancementValues[1]) == True;
		"If eyes are above lowest point of wall"
		Is True For Any(All Living Players(Team 1), Y Component Of(Eye Position(Current Array Element)) > Y Component Of(
			Event Player.enhancementValues[4])) == True;
		"Distance from wall"
		Is True For Any(All Living Players(Team 1), Distance Between(Vector(X Component Of(Position Of(Current Array Element)),
			Y Component Of(Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element))),
			Event Player.enhancementValues[5] + Event Player.enhancementValues[9] * Min(Event Player.enhancementValues[2], Absolute Value(
			Cosine From Degrees(Angle Between Vectors(Event Player.enhancementValues[9], Direction Towards(
			Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element)))))) * Distance Between(
			Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element))))))) < 1.500) == True;
	}

	actions
	{
		Stop Chasing Player Variable(Event Player, enhancementChase1);
		"Horizontal distance check"
		Event Player.potentialTargets = Filtered Array(All Living Players(Team 1), Distance Between(Event Player.enhancementValues[4],
			Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(Position Of(Event Player.enhancementValues[4])),
			Z Component Of(Position Of(Current Array Element)))) < 0.500 * Event Player.enhancementValues[2]);
		"Filter feet height"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, Y Component Of(Position Of(Current Array Element))
			< Y Component Of(Event Player.enhancementValues[4]) + Event Player.enhancementValues[1]);
		"Filter eye height"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, Y Component Of(Eye Position(Current Array Element))
			> Y Component Of(Event Player.enhancementValues[4]));
		"Filter distance from wall"
		Event Player.potentialTargets = Filtered Array(Event Player.potentialTargets, Distance Between(Vector(X Component Of(Position Of(
			Current Array Element)), Y Component Of(Event Player.enhancementValues[5]), Z Component Of(Position Of(
			Current Array Element))), Event Player.enhancementValues[5] + Event Player.enhancementValues[9] * Min(
			Event Player.enhancementValues[2], Absolute Value(Cosine From Degrees(Angle Between Vectors(Event Player.enhancementValues[9],
			Direction Towards(Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element)))))) * Distance Between(
			Event Player.enhancementValues[5], Vector(X Component Of(Position Of(Current Array Element)), Y Component Of(
			Event Player.enhancementValues[5]), Z Component Of(Position Of(Current Array Element))))))) < 1.500);
		For Player Variable(Event Player, enhancementCount1, 0, Count Of(Event Player.potentialTargets), 1);
			Event Player.botTarget = Event Player.potentialTargets[Event Player.enhancementCount1];
			If(!Has Status(Event Player.botTarget, Rooted));
				"Damage the barricade"
				Event Player.enhancementChase1 -= Max Health(Event Player.botTarget) * 2.500;
				Set Status(Event Player.botTarget, Event Player, Rooted, 0.500);
				Damage(Event Player.botTarget, Event Player, 10);
			End;
			If(Throttle Of(Event Player.botTarget) == Vector(0, 0, 0));
				"If bot is not throttling"
				Apply Impulse(Event Player.botTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(
					Event Player.enhancementValues[4], First Of(Sorted Array(Filtered Array(Event Player.enhancementValues,
					Current Array Index >= 7 && Current Array Index <= 8), Distance Between(Position Of(Event Player.botTarget),
					Current Array Element))))), (Y Component Of(Position Of(Event Player.botTarget)) > Y Component Of(
					Event Player.enhancementValues[4]) ? -1 : 1) * (90 + Vertical Angle From Direction(Ray Cast Hit Normal(Position Of(
					Event Player.botTarget), Position Of(Event Player.botTarget) + Vector(0, -1, 0), Null, All Players(All Teams), False)))), 1,
					To World, Incorporate Contrary Motion);
			Else;
				"If bot is throttling"
				Apply Impulse(Event Player.botTarget, Direction From Angles(Horizontal Angle From Direction(Direction Towards(
					Event Player.enhancementValues[4], Last Of(Sorted Array(Filtered Array(Event Player.enhancementValues,
					Current Array Index >= 7 && Current Array Index <= 8), Angle Between Vectors(World Vector Of(Throttle Of(
					Event Player.botTarget), Event Player.botTarget, Rotation), Direction Towards(Event Player.enhancementValues[4],
					Current Array Element)))))), (Y Component Of(Position Of(Event Player.botTarget)) > Y Component Of(
					Event Player.enhancementValues[4]) ? -1 : 1) * (90 + Vertical Angle From Direction(Ray Cast Hit Normal(Position Of(
					Event Player.botTarget), Position Of(Event Player.botTarget) + Vector(0, -1, 0), Null, All Players(All Teams), False)))), 10,
					To World, Cancel Contrary Motion);
			End;
		End;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		If(Event Player.enhancementChase1 > 0);
			Wait(3, Restart When True);
		Else;
			Wait(6, Restart When True);
			"If shield is regenerating from 0HP"
			If(Event Player.enhancementChase1 <= 0);
				Event Player.enhancementChase1 = 1;
			End;
		End;
		Chase Player Variable At Rate(Event Player, enhancementChase1, 10000, 500, None);
		Loop If Condition Is True;
	}
}

rule("BRAIN KILLER EXTRA DAMAGE")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 4;
		Event Was Critical Hit == True;
	}

	actions
	{
		"Critical hits deal 50% more damage, 20% if vicitm is a boss"
		Damage(Victim, Event Player, Event Damage * (Array Contains(Global.bosses, Victim) ? 0.200 : 0.600));
		Play Effect(Event Player, Bad Explosion, Custom Color(100, 14, 14, 255), Eye Position(Victim) + Direction Towards(Eye Position(
			Event Player), Eye Position(Victim)) * Victim.size, 0.100 * Victim.size);
	}
}

rule("PYROTECHNIC SETS ENEMIES ON FIRE")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		First Of(Attacker.enhancementValues) == 5;
		Attacker.enhancementValues[1] == True;
		Victim != Event Player;
		Event Ability != Null;
		Distance Between(Position Of(Attacker), Position Of(Victim)) < 10;
	}

	actions
	{
		Set Status(Victim, Attacker, Burning, 3);
		Modify Player Variable(Attacker, enhancementChase2, Append To Array, Victim);
	}
}

rule("PYROTECHNIC APPLIES DAMAGE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 5;
		Count Of(Event Player.enhancementChase2) > 0;
	}

	actions
	{
		While(Count Of(Event Player.enhancementChase2) > 0);
			"Zombie to burn"
			Event Player.enhancementValues[3] = First Of(Event Player.enhancementChase2);
			If(Is Alive(Event Player.enhancementValues[3]));
				"Amount of times zombie was hit in last cycle"
				Event Player.enhancementValues[4] = Min(4 * Count Of(Filtered Array(Event Player.enhancementChase2,
					Current Array Element == Event Player.enhancementValues[3])), 30);
				If(Array Contains(Global.bosses, Event Player.enhancementValues[3]));
					Event Player.enhancementValues[4] /= 2;
				End;
				Start Damage Over Time(Event Player.enhancementValues[3], Event Player, 3, Event Player.enhancementValues[4]);
			End;
			Modify Player Variable(Event Player, enhancementChase2, Remove From Array By Value, Event Player.enhancementValues[3]);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("BORN TO BATTLE PLAYER EARNS ELIMINATION")
{
	event
	{
		Player Dealt Final Blow;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 7;
		Event Player.enhancementValues[1] != True;
	}

	actions
	{
		Event Player.enhancementValues[1] = True;
	}
}

rule("BORN TO BATTLE PLAYER USES ABILITY CHARGE")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 7;
		Event Player.enhancementValues[1] == True;
		Is True For Any(Array(Button(Secondary Fire), Button(Ability 1), Button(Ability 2), Button(Crouch)), Is Button Held(Event Player,
			Current Array Element)) == True;
	}

	actions
	{
		If(Is Button Held(Event Player, Button(Secondary Fire)));
			Event Player.enhancementValues[2] = Button(Secondary Fire);
		Else If(Is Button Held(Event Player, Button(Ability 1)));
			Event Player.enhancementValues[2] = Button(Ability 1);
		Else If(Is Button Held(Event Player, Button(Ability 2)));
			Event Player.enhancementValues[2] = Button(Ability 2);
		Else If(Is Button Held(Event Player, Button(Crouch)));
			Event Player.enhancementValues[2] = Button(Crouch);
		End;
		"Temp rein fix ability 2"
		If((Hero Of(Event Player) == Hero(Reinhardt) || Hero Of(Event Player) == Hero(Zarya))
			&& Event Player.enhancementValues[2] == Button(Ability 2));
			Wait Until(Is Using Ability 2(Event Player), 0.016);
			If(!Is Using Ability 2(Event Player));
				Set Ability Charge(Event Player, Event Player.enhancementValues[2], 1);
				Event Player.enhancementValues[1] = False;
			End;
			Abort;
		End;
		"Temp zarya fix ability 1"
		If(Hero Of(Event Player) == Hero(Zarya) && Event Player.enhancementValues[2] == Button(Ability 1));
			Wait Until(Is Using Ability 1(Event Player), 0.016);
			If(!Is Using Ability 1(Event Player));
				Set Ability Charge(Event Player, Event Player.enhancementValues[2], 1);
				Event Player.enhancementValues[1] = False;
			End;
			Abort;
		End;
		Set Ability Charge(Event Player, Event Player.enhancementValues[2], Ability Charge(Event Player, Event Player.enhancementValues[2])
			+ 1);
		"If the ability charge increased"
		If(Ability Charge(Event Player, Event Player.enhancementValues[2]) > 0);
			Event Player.enhancementValues[1] = False;
		"Else if ability is on cooldown"
		Else If(Ability Cooldown(Event Player, Event Player.enhancementValues[2]) > 0.500);
			Set Ability Cooldown(Event Player, Event Player.enhancementValues[2], 0);
			Event Player.enhancementValues[1] = False;
		End;
	}
}

rule("PLAGUE DOCTOR REDUCES PLAYERS' INFECTION LEVELS")
{
	event
	{
		Player Dealt Healing;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 6;
		Healee.infectionLvl >= 1;
	}

	actions
	{
		Healee.infectionLvl -= Event Healing / 300;
		Event Player.enhancementValues[1] += Event Healing / 300;
		If(Healee.infectionLvl < 1);
			Healee.infectionLvl -= 0.500;
			Event Player.enhancementValues[1] += 0.500;
			Play Effect(Event Player, Good Pickup Effect, Color(Green), Healee, 1);
			Small Message(Event Player, Healee == Event Player ? Custom String("You cured yourself!") : Custom String("You cured {0} {1}!",
				Healee, Hero Icon String(Hero Of(Healee))));
	}
}

rule("NANO NURSE SELF HEALING")
{
	event
	{
		Player Took Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 9;
		Is Alive(Event Player) == True;
	}

	actions
	{
		If(Event Player.enhancementValues[1] != 0);
			Stop Heal Over Time(Event Player.enhancementValues[1]);
			Global.enhancementOptions[1] = 0;
			Event Player.enhancementValues[2] = False;
			Stop Chasing Player Variable(Event Player, infectionLvl);
		End;
		Wait Until(!Event Player.infected, 99999);
		Wait(0.500, Restart When True);
		Abort If(Is Dead(Event Player));
		Event Player.enhancementValues[2] = True;
		If(Event Player.infectionLvl > 0);
			Chase Player Variable At Rate(Event Player, infectionLvl, 0, 0.100, None);
		End;
		While(Normalized Health(Event Player) < 1);
			Start Heal Over Time(Event Player, Event Player, 1, 20);
			Event Player.enhancementValues[1] = Last Heal Over Time ID;
			Wait(1, Restart When True);
		End;
	}
}

rule("HITCHHIKER ATTACH/DETATCH")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 10;
		(Is Button Held(Event Player, Button(Crouch)) || (Event Player.attached && (Is Dead(Event Player) || Is Dead(
			Event Player.enhancementValues[1]) || !Entity Exists(Event Player.enhancementValues[1]) || Has Status(Event Player,
			Knocked Down) || Has Status(Event Player, Stunned) || Distance Between(Position Of(Event Player), Position Of(
			Event Player.enhancementValues[1])) > 3 * Event Player.enhancementValues[1].size))) == True;
	}

	actions
	{
		If(!Event Player.attached && Is Alive(Event Player));
			If(Is True For Any(Remove From Array(Global.playerTargetList, Event Player), !Current Array Element.attached && Distance Between(
				Position Of(Event Player), Position Of(Current Array Element)) < 2 * Current Array Element.size));
				"Select parent"
				Event Player.enhancementValues[1] = First Of(Sorted Array(Filtered Array(Remove From Array(Global.playerTargetList, Event Player),
					!Current Array Element.attached && Distance Between(Position Of(Event Player), Position Of(Current Array Element))
					< Current Array Element.size * 2), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(
					Event Player), Eye Position(Current Array Element)))));
				"World Vector"
				Event Player.enhancementValues[2] = Position Of(Event Player.enhancementValues[1]) + Direction From Angles(
					Horizontal Angle From Direction(Direction Towards(Position Of(Event Player.enhancementValues[1]), Position Of(Event Player))),
					0) * Event Player.enhancementValues[1].size + Vector(0, Event Player.enhancementValues[1].size, 0);
				"Local vector conversion"
				Event Player.enhancementValues[2] = Local Vector Of(Event Player.enhancementValues[2], Event Player.enhancementValues[1],
					Rotation And Translation);
				"Translate player behind parent"
				If(Z Component Of(Event Player.enhancementValues[2]) > 0);
					Event Player.enhancementValues[2] *= Vector(1, 1, -1);
				End;
				Event Player.attached = True;
				Attach Players(Event Player, Event Player.enhancementValues[1], Event Player.enhancementValues[2]);
				Small Message(Event Player, Custom String("You are attached"));
			End;
		Else;
			If(Entity Exists(Event Player.enhancementValues[1]) && Distance Between(Position Of(Event Player), Position Of(
				Event Player.enhancementValues[1])) < 3 * Event Player.enhancementValues[1].size);
				Teleport(Event Player, Position Of(Event Player.enhancementValues[1]));
			Else;
				Detach Players(Event Player);
			End;
			Small Message(Event Player, Custom String("You have detached"));
			Event Player.attached = False;
			Event Player.enhancementValues[1] = 0;
	}
}

rule("P.U.P. TARGET")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 11;
		"Cooldown is at 0s"
		Event Player.enhancementChase2 <= 0;
		"P.U.P. target"
		Event Player.enhancementValues[3] == Null;
		Is True For Any(All Living Players(Team 1), Current Array Element.botTarget == Event Player && Distance Between(Position Of(
			Event Player), Position Of(Current Array Element)) < 10) == True;
	}

	actions
	{
		"Set P.U.P. target"
		Event Player.enhancementValues[3] = First Of(Sorted Array(Filtered Array(All Living Players(Team 1),
			Current Array Element.botTarget == Event Player), Distance Between(Position Of(Event Player), Position Of(
			Current Array Element))));
		Wait Until(Is Dead(Event Player.enhancementValues[3]) || !Entity Exists(Event Player.enhancementValues[3])
			|| Event Player.enhancementValues[3].teleporting, 99999);
		Stop Chasing Player Variable(Event Player, enhancementChase1);
		Event Player.enhancementValues[3] = Null;
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
		Stop Chasing Player Variable(Event Player, enhancementChase1);
		"Default color"
		Event Player.enhancementValues[1] = Color(Sky Blue);
		"Beam visibility"
		Event Player.enhancementValues[2] = False;
		"P.U.P. target null"
		Event Player.enhancementValues[3] = Null;
		"Freeze aura visibility"
		Event Player.enhancementValues[4] = False;
		Wait(0.500, Restart When True);
		"P.U.P. Default movement"
		Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player) + Direction Towards(Eye Position(
			Event Player), Event Player.enhancementChase1), Absolute Value(Distance Between(Eye Position(Event Player),
			Event Player.enhancementChase1) - 1), Destination and Rate);
	}
}

rule("P.U.P. CONTROL")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.enhancementValues[0] == 11;
		Event Player.enhancementValues[3] != Null;
	}

	actions
	{
		"P.U.P. attack movement"
		Chase Player Variable At Rate(Event Player, enhancementChase1, Eye Position(Event Player.enhancementValues[3]) + Direction Towards(
			Eye Position(Event Player.enhancementValues[3]), Event Player.enhancementChase1) * 2, Absolute Value(Distance Between(
			Eye Position(Event Player.enhancementValues[3]), Event Player.enhancementChase1) - 2) * 1.500, Destination and Rate);
		"Default color"
		Event Player.enhancementValues[1] = Color(Sky Blue);
		"Beam visibility"
		Event Player.enhancementValues[2] = False;
		"Freeze aura visibility"
		Event Player.enhancementValues[4] = False;
		Wait Until(Distance Between(Event Player.enhancementChase1, Eye Position(Event Player.enhancementValues[3]))
			< 5 || Event Player.enhancementValues[3] == Null, 99999);
		"If target still exists"
		If(Event Player.enhancementValues[3] != Null);
			If(Distance Between(Position Of(Event Player), Position Of(Event Player.enhancementValues[3])) > 6);
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(White);
				"Beam visibility"
				Event Player.enhancementValues[2] = True;
				"Freeze aura visibility"
				Event Player.enhancementValues[4] = True;
				Wait(0.250, Abort When False);
				Play Effect(All Players(All Teams), Bad Explosion, Color(Sky Blue), Event Player.enhancementValues[3], 0.100);
				"Time to freeze dependent on max health of target"
				Wait(Min(15, Max Health(Event Player.enhancementValues[3]) / 300), Abort When False);
				"Freeze cooldown"
				Event Player.enhancementChase2 = 2;
				Set Status(Event Player.enhancementValues[3], Event Player, Frozen, 1.500);
				While(!Has Status(Event Player.enhancementValues[3], Frozen));
					Set Status(Event Player.enhancementValues[3], Event Player, Frozen, 1.500);
					Wait(0.250, Abort When False);
				End;
				"Freeze zombies around target for shorter time"
				Set Status(Remove From Array(Filtered Array(All Players(Team 1), Distance Between(Position Of(Event Player.enhancementValues[3]),
					Position Of(Current Array Element)) < 3), Event Player.enhancementValues[3]), Event Player, Frozen, 0.750);
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(Sky Blue);
				"Beam visibility"
				Event Player.enhancementValues[2] = False;
				"Freeze aura visibility"
				Event Player.enhancementValues[4] = False;
			Else;
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(Red);
				"Beam visibility"
				Event Player.enhancementValues[2] = True;
				Start Damage Over Time(Event Player.enhancementValues[3], Event Player, 3, 30);
				"Beam from P.U.P."
				Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Event Player.enhancementChase1, 0.250);
				"Beam hits P.U.P.'s target"
				Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Event Player.enhancementValues[3], 1);
				Set Status(Event Player.enhancementValues[3], Event Player, Burning, 3);
				Apply Impulse(Event Player.enhancementValues[3], Direction From Angles(Horizontal Angle From Direction(Direction Towards(
					Event Player.enhancementChase1, Position Of(Event Player.enhancementValues[3]))), Min(-20, Vertical Angle From Direction(
					Direction Towards(Event Player.enhancementChase1, Position Of(Event Player.enhancementValues[3]))))), Min(25,
					4200 / Max Health(Event Player.enhancementValues[3])), To World, Cancel Contrary Motion);
				Set Status(Event Player.enhancementValues[3], Event Player, Knocked Down, 1);
				"Laser cooldown"
				Event Player.enhancementChase2 = 1;
				Wait(3, Abort When False);
				"P.U.P. color"
				Event Player.enhancementValues[1] = Color(Sky Blue);
				"Beam visibility"
				Event Player.enhancementValues[2] = False;
			End;
			Stop Chasing Player Variable(Event Player, enhancementChase1);
			"P.U.P. target"
			Event Player.enhancementValues[3] = Null;
			Wait(1, Abort When False);
		End;
		Loop If Condition Is True;
	}
}